# 디자인 패턴(Design Pattern)

프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 규약 형태로 만들어 놓은 것. 라이브러리나 프레임워크의 기반이 된다.

## GoF 디자인 패턴

소프트웨어 공학에서 가장 많이 사용되는 디자인 패턴으로 목적에 따라 생성 패턴, 구조 패턴, 행위 패턴으로 구성된다.

### 생성 패턴

- 객체 생성과 관련된 패턴으로 객체의 인스턴스 과정을 추상화하는 패턴
- 객체의 생성과 참조 과정을 캡슐화하여 객체의 변화에도 프로그램 구조에 영향을 받지 않도록 하여 유연성을 높인다.
- 싱글톤
  - 어떤 클래스의 인스턴스는 하나임을 보장하고 어디서든 참조할 수 있게 함
- 팩토리 메서드
  - 객체 생성을 서브클래스로 위임하여 캡슐화
- 추상팩토리
  - 인터페이스를 통해 서로 연관되는 객체들을 그룹화
- 빌더
  - 복합 객체의 생성과 표현을 분리, 동일한 생성 절차에도 다른 표현 결과를 만들어 냄
- 프로토타입
  - 원본 객체를 복사함으로서 객체를 생성

### 구조 패턴

- 클래스나 객체를 조합해 더 큰 구조로 만들 수 있게 하는 패턴
- 프록시
  - 접근이 어려운 객체로의 접근을 제어하기 위해 객체의 Surrogate나 Placeholder 제공
- 어댑터
  - 클래스의 인터페이스를 다른 인터페이스로 변환하여 다른 클래스가 이용할 수 있게 함
- 브릿지
  - 구현부에서 추상층을 분리하여 각자 독립적으로 확장이 가능하게 함
- 컴포지트
  - 객체들의 관계를 트리 구조로 구성, 복합 객체와 단일 객체를 구분 없이 다룸
- 데코레이터
  - 주어진 상황, 용도에 따라 어떤 객체에 다른 객체를 덧붙이는 방식
- 퍼사드
  - 서브시스템의 인터페이스 집합에 대해 하나의 통합된 인터페이스 제공
- 플라이웨이트
  - 크기가 작은 여러 개의 객체를 매번 생성하지 않고 가능한 한 공유할 수 있도록 하여 메모리를 절약

### 행동 패턴

- 클래스나 객체들이 서로 상호작용하는 방법 혹은 객체나 클래스 간 알고리즘, 책임 할당 등에 관한 디자인 패턴
- 이터레이터
  - 내부를 노출하지 않고 접근이 잦은 객체의 원소를 순차적으로 접근할 수 있는 동일한 인터페이스 제공
- 옵저버
  - 객체의 상태가 변할 때 관련 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 함
- 전략
  - 동일 계열의 알고리즘군을 정의하고 캡슐화하여 상호교환이 가능하게 함
- 책임 연쇄
  - 요청 받는 객체를 연쇄적으로 묶어 처리하는 객체를 만날 때까지 객체 체인을 따라 요청을 전달
- 커맨드
  - 요청을 객체의 형태로 캡슐화하여 재사용하거나 취소할 수 있도록 저장
- 중재자
  - 한 집합에 속해있는 객체들의 상호작용을 캡슐화하여 새로운 객체로 정의
- 메멘토
  - 객체가 특정 상태로 다시 되돌아올 수 있도록 내부 상태를 실체화
- 상태
  - 객체의 상태에 따라 동일한 동작을 다르게 처리할 때 사용
- 탬플릿메서드
  - 상위 클래스는 알고리즘의 골격만들 작성, 구체적인 처리는 서브 클래스로 위임
- 비지터
  - 객체의 원소에 대해 수행할 연산을 분리하여 별도의 클래스로 구성

GoF 패턴 외에도 flux, MVC, MVVM 등 다양한 패턴들이 존재한다.
