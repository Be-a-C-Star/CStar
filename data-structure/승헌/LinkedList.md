# 연결리스트(Linked List)
연결리스트는 데이터를 노드(Node) 단위로 저장하고,
각 노드가 다음 노드의 주소(포인터)를 저장하는 방식으로 구성되는 선형 자료구조.
배열과 달리 메모리 상 연속적일 필요가 없고, 삽입/삭제가 빠름

### 시간복잡도
- 접근(Access): $O(n)$
- 탐색(Search): $O(n)$
- 삽입(Insert):
    - 처음(head) 또는 포인터로 위치를 알고 있는 경우: $O(1)$
    - 특정 값 뒤에 삽입:
    포인터를 알고 있는 경우 $O(1)$
    값을 찾아서 하는 경우 $O(n)$
- 삭제(Delete)
    - 삭제할 노드의 주소를 알고 있는 경우 $O(1)$
    - 값으로 찾아서 삭제: $O(n)$

## 싱글연결리스트
- 각 노드가 데이터 + next 포인터로 구성
- 끝 노드의 포인터는 `null`
### 특징
- 앞에서부터 순차적 탐색 가능
- 메모리 사용 상대적으로 낮음
### **시간복잡도**
- 접근: $O(n)$
- 탐색: $O(n)$
- 삽입/삭제(앞): $O(1)$
- 삽입/삭제(중간/끝): $O(n)$
    - 해당 위치 찾는 과정 필요

## 이중연결리스트
- 각 노드가 **데이터 + prev 포인터 + next 포인터** 로 구성됨.
- 양방향 이동 가능
### **특징**
- 이전 노드, 다음 노드 모두 접근 가능
- 삽입/삭제 시 포인터 업데이트가 필요하지만, 방향이 양쪽이라 효율적
### **시간복잡도**
- 접근: $O(n)$
- 탐색: $O(n)$
- 삽입/삭제:
포인터를 알고 있는 경우 $O(1)$
값을 찾아서 하는 경우 $O(n)$

## 원형연결리스트
### 원형싱글연결리스트
- 마지막 노드의 next가 **head**를 가리킴
- 리스트의 끝과 처음이 연결되어 있음
### **특징**
- 끝에서 다시 시작할 수 있음
- head만 알고 있어도 전체 순회 가능
### **시간복잡도**
- 접근: $O(n)$
- 탐색: $O(n)$
- 삽입/삭제(앞): $O(1)$
- 삽입/삭제(중간/끝): $O(n)$

### 원형이중연결리스트
- 이중 연결리스트의 **끝과 처음이 서로 연결**됨
- 즉, head의 prev는 tail, tail의 next는 head
### **특징**
- 양방향 탐색 가능 + 원형 순회 가능
- 큐(특히 **덱, 우선순위 큐**) 구현에 자주 활용됨
### **시간복잡도**
- 접근: $O(n)$
- 탐색: $O(n)$
- 삽입/삭제(포인터 기반): $O(1)$
- 삽입/삭제(탐색 포함): $O(n)$

## 랜덤접근과 순차적 접근
### **배열(Array):**
- 랜덤 접근: 가능 $O(1)$ → 인덱스로 바로 접근
- 삽입/삭제: 느림 $O(n)$ → 요소 이동 필요
### **연결리스트(Linked List):**
- 랜덤 접근: 불가능 $O(n)$ → 순차 탐색만 가능
- 삽입/삭제: 빠름 $O(1)$ → 포인터만 바꿔주면 됨
    포인터를 알고 있는 경우 $O(1)$
    값을 찾아서 하는 경우 $O(n)$