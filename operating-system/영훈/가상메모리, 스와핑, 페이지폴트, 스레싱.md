### 가상 메모리(Virtual Memory)

###### OS에서 사용되는 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용가능한 메모리 자원(실제 주소, Physical Address)을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말한다.

- 가상 주소는 MMU와 페이지테이블(page table)에 의해 실제 주소로 변환됨
- 페이지: 가상 메모리를 사용하는 최소 크기 단위
- 프레임: 실제 디스크나 메모리를 사용하는 최소 크기 단위

![alt text](<스크린샷 2025-04-01 오후 6.09.16.png>)

---

### 페이지 테이블

![alt text](<스크린샷 2025-04-01 오후 6.10.55.png>)

- 가상 메모리는 가상 주소와 실제 주소가 매핑되어있는 페이지 테이블로 관리되며 이 때 속도 향상을 위해 캐싱 계층인 TLB를 쓴다.
- 가상 주소에서 바로 페이지 테이블을 가는게 아니라 TLB에서 있는지를 확인하고 만약 없다면 페이지 테이블로 가서 실제 주소를 가져온다.

---

#### 프로세스 A와 프로세스 B가 실행 및 종료시의 메모리 할당 과정

##### 가상 메모리와 물리 메모리

- 각 프로세스는 자신만의 가상 주소 공간을 가지고 있다.
- 가상 주소는 프로세스가 메모리에 접근할 때 사용하는 주소이다.
- 물리 메모리는 실제로 존재하는 RAM의 주소 공간이며 가상 주소는 실제로 물리 메모리의 주소와 직접적인 관계가 없다.
- 이를 매핑해주는 페이지 테이블이 있고 이걸 기반으로 CPU의 메모리 관리 유닛(MMU,
  Memory Management Unit)이 가상주소를 물리주소로 변환한다.

##### 프로세스의 종료와 재실행

- 프로세스 A와 B가 종료되면, 그들의 가상 주소 공간과 페이지 테이블은 해제된다.
- A와 B가 다시 실행되면, 운영 체제는 새로운 가상 주소 공간을 할당한다.
- 이 가상 주소 공간이 이전과 동일하지 않을 수 있다.
- 운영 체제는 가상 주소를 자유롭게 재사용할 수 있다.
- 중요한 점은 가상 주소가 동일하더라도, 실제 물리 메모리 주소는 다를 수 있다.
- 가상 주소는 항상 페이지 테이블을 통해 물리 주소로 변환된다.

##### 처음 실행

![alt text](<스크린샷 2025-04-01 오후 6.36.28.png>)

- 프로세스 A: 가상 주소 0x00, 0x04 할당
- 프로세스 B: 가상 주소 0x00, 0x04 할당
- A의 0x00, 0x04 가상 주소는 실제 물리 메모리 주소 0x02, 0x05에 매핑
- B의 0x00, 0x04 가상 주소는 실제 물리 메모리 주소 0x09, 0x01에 매핑

##### 종료 후 재실행

![alt text](<스크린샷 2025-04-01 오후 6.46.07.png>)
A와 B가 종료되고 메모리에서 해제됨
A와 B가 다시 실행됨

- 프로세스 A: 가상 주소 0x00, 0x04 할당 (이전과 동일할 수도 있고 다를 수도 있음)
- 프로세스 B: 가상 주소 0x00, 0x04 할당 (이전과 동일할 수도 있고 다를 수도 있음)
- 하지만, 이번에는 A의 0x00, 0x04 가상 주소가 물리 주소 0x10, 0x30에 매핑될 수 있음
- B의 0x00, 0x04 가상 주소가 물리 주소 0x50, 0x90에 매핑될 수 있음

---

### 페이지폴트

- 가상메모리는 작은 메모리를 매우 큰 메모리로 보이게끔 하는 것이기 때문에 참조하려는 메모리 영역이 실제에는 없을 수도 있다.

![alt text](<스크린샷 2025-04-01 오후 6.53.16.png>)

- 즉, 가상 메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우가 있으며 이 때 페이지 폴트가 발생한다.
- 또한, 운영체제는 전체 프로세스의 메모리 내용을 디스크로부터 한 번에 RAM에 올리지 않고 처음에 필요한 부분들만 효율적으로 올린다. 그렇기 때문에 이런 현상이 일어나는 것이다.

#### 스와핑

![alt text](<스크린샷 2025-04-01 오후 6.54.47.png>)

- 이 때 메모리의 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 “마치 메모리처럼” 불러와 쓰는 것을 스와핑이라고 한다.

#### 페이지 폴트의 이후의 과정

1. 페이지폴트 이후 OS에게 트랩을 전송한다. OS는 먼저 페이지 폴트가 유효한 접근인지 점검한다. 만약 비정상적인 접근이라면 프로세스를 강제 종료할 수 있다.
2. OS는 물리 메모리에서 빈 프레임이 있는지 확인하고 다음의 과정이 일어난다.

- 빈 프레임이 있을 경우

  - 디스크에서 필요한 페이지를 바로 메모리로 가져와 적재한다(Swap-in). 이 때, 기존 페이지를 내보내는 작업(Swap-out)은 없다.

- 빈 프레임이 없을 경우
  - 페이지 교체 알고리즘을 수행하여 기존의 한 페이지를 선택한다.
  - 선택된 페이지를 디스크로 내보낸다. (Swap-out),
  - 빈 프레임을 확보한 뒤 필요한 페이지를 디스크에서 메모리로 가져온다(Swap-in).

![alt text](<스크린샷 2025-04-01 오후 7.10.55.png>)

- 이 때 디스크 I/O 작업은 CPU 처리 속도에 비해 매우 느리므로, 페이지 폴트가 자주 발생할수록 CPU는 작업을 하지 못하고 대기 시간이 증가하여 CPU 이용률이 저하된다.

  - 메모리 접근 시간: 수백 나노초(ns) 수준
  - 디스크 접근 시간: 수 밀리초(ms) 수준(수백만 나노초)

- 운영체제에서 스와핑은 일반적으로 디스크와 메모리 간에 데이터를 교환하는 전체 과정을 의미하며 아래 두 과정을 합쳐 스와핑으로 부르거나 각각 스와핑으로 부르기도 한다.

  - Swap-in: 디스크 → 메모리
  - Swap-out: 메모리 → 디스크

- 디스크 스왑 영역
  - 물리 메모리가 부족할 때, 사용하지 않는 메모리 페이지를 하드 디스크의 특정 영역으로 옮겨 저장하는 공간을 스왑 영역이라고 한다.

---

### 스레싱

###### 실제 프로세스 실행보다 스와핑 작업에 대부분의 시간이 소요되는 현상

- 페이지 폴트가 빈번하게 발생하면, 필요한 데이터를 디스크에서 메모리로 불러오는 과정이 잦아지고 이로 인해 스와핑이 과도하게 일어난다.
- 그 결과, CPU는 실제 연산을 수행하기보다 스와핑 대기 상태에 머무르게 되어 전체적인 CPU 이용률이 낮아진다.
- 이러한 상황에서 운영체제는 CPU의 낮은 사용률을 보완하고자 추가 프로세스를 메모리에 적재하게 되는데, 이는 이미 부족한 메모리 자원을 더욱 압박하게 된다.
- 결국, 메모리 부족과 빈번한 페이지 폴트가 서로를 악화시키는 악순환이 발생하고, 이로 인해 시스템 전체의 성능이 급격히 저하되는 스레싱 현상이 나타난다.

![alt text](<스크린샷 2025-04-01 오후 7.00.06.png>)

#### 해결 방법

하드웨어적으로 해결하는 방법으로는 메모리를 늘리거나 HDD를 사용한다면 HDD를 SSD로 바꾸는 방법이 있으며 운영체제에서 해결하는 방법은 작업세트와 PFF가 있다.

##### 작업 세트(Working Set)

- 프로세스의 과거 사용이력을 기반으로 많이 사용하는 페이지 집합을 만들어 한꺼번에 미리 메모리에 로드하는 것

##### PFF(Page Fault Frequency)

###### 각 프로세스의 페이지 폴트 발생 빈도를 모니터링하여, 메모리 프레임의 할당량을 동적으로 조절하는 방법

![alt text](<스크린샷 2025-04-01 오후 7.15.24.png>)

##### 상한선 초과

- 프로세스의 페이지 폴트 빈도가 상한선에 도달하면, 해당 프로세스에 더 많은 프레임을 할당하여 작업세트를 확장시킨다.

##### 하한선 미달

- 프로세스의 페이지 폴트 빈도가 하한선에 도달하면, 운영체제는 이 경우 일부 프레임을 회수하여 다른 프로세스에 재할당할 수 있다.

---

### 가상 메모리의 장점

#### 메모리 효율적 사용

- 가상 메모리는 프로그램 실행 시 모든 데이터를 한꺼번에 메모리에 적재하지 않고, 실제로 필요한 시점에 해당 메모리 페이지만 동적으로 불러온다.
- 이 덕분에 제한된 RAM 내에서도 대용량 프로그램을 효율적으로 실행할 수 있으며, 이러한 방식을 Demand Paging(요구 페이징)이라고 한다.

#### 메모리 과잉 할당

- 운영체제는 각 프로세스에 가상 주소 공간을 넉넉하게 할당하여 실제 RAM보다 훨씬 큰 주소 공간을 사용할 수 있어서 메모리 자원을 최대한 효율적으로 배분할 수 있다.
- 예를 들어 가상 메모리 없이 메모리가 8GB인데 리그오브 레전드 게임(5.49GB) 등을 한꺼번에 올린다고 생각하면 끔찍 할 것이다.

#### 프로세스 간 메모리 보호

- 각 프로세스는 독립적인 가상 주소 공간을 갖고, 동일한 가상 주소라도 서로 다른 물리 메모리 영역에 매핑된다.
- 이를 통해 오류나 데이터 충돌이 한 프로세스에 국한되어 다른 프로세스에 영향을 주지 않고 특정 프로세스의 악의적 접근을 방지할 수 있다.

#### 메모리 접근 제어

- 가상 메모리는 메모리를 일정한 크기의 페이지로 나누어 관리하는데 이 때 읽기, 쓰기, 실행 권한을 설정할 수 있다.
- 권한 없는 접근 시도가 즉시 감지되고 차단되어, 버퍼 오버플로우나 코드 인젝션 같은 보안 위협을 예방한다.
