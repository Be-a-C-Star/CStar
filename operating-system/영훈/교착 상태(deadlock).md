# 교착 상태(deadlock)

###### 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 말한다. 이 과정에서 각 프로세스는 서로가 원하는 자원을 유지한채 다른 프로세스의 자원을 얻기를 기다린다.

![alt text](<스크린샷 2025-04-28 오후 2.21.08.png>)

## 교착 상태의 원인

교착상태가 발생하기 위한 4가지 필요조건은 다음과 같다.

- 상호 배제: 주어진 시간 내에 하나의 프로세스만 자원을 독점할 수 있다. 즉, 다른 프로세스들은 접근이 불가능하다.
- 점유 대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하며 대기하는 상태이다.
- 비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없다.
- 환형 대기: 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황을 말한다.

## 교착 상태의 해결 방법

1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계한다.
2. 교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당가능 여부를 파악하는 '**은행원 알고리즘**'을 쓴다.
3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지운다.
4. 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커서 교착 상태가 발생하면 사용자가 작업을 종료한다.

- 현대 운영체제는 이 방법을 채택한다. 예를 들어 프로세스를 실행시키다 '응답 없음'이라고 뜰 때가 있는데, 교착 상태가 발생한 경우에 이와 같은 경우가 발생하기도 한다.

---

### 은행원 알고리즘(Banker’s Algorithm)

###### 교착상태를 회피하는 알고리즘으로 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정 또는 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘

- 안정상태
  - 교착상태를 일으키지 않은 상태이며 프로세스의 최대 자원 요구량을 운영체제가 충족시킬 수 있는 상태
- 불안정상태

  - 안전상태로 가는 순서열이 존재하지 않는 상태

은행원 알고리즘이 사용하는 자료구조는 다음과 같다.

- n \* m 2차원 배열 3개와 n 1차원 배열 2개를 사용

#### 은행원 알고리즘의 구조

- `available[i]` : 운영체제가 프로세스에게 자원을 줄 수 있는 양 / i번째 사용 가능한 자원의 양
- `max[i][j]` : 프로세스 최대요구량 / 프로세스 i가 자원 j를 최대 요청할 수 있는 양
- `allocation[i][j]` : 프로세스 자원 할당양 / 프로세스 i에 자원 j를 할당한 양
- `need[i][j]` : 프로세스의 자원 추가 요구량 / 프로세스 i가 자원 j를 추가 요청하는 양
- `finish[i]` : i번째 프로세스가 요청하는 양을 운영체제가 만족할 수 있는지를 파악할 수 있는 불리언 배열

#### 은행원 알고리즘 순서

다음의 프로세스를 기반으로 수행된다.

1. `request[i] <= need[i]` / 해당 조건 불충족시 오류
2. `request[i] <= available[i]` /해당 조건 불충족시 대기
3. 이후 `request[i]`의 값이 `available[i]`에 더해지며 `need[i]`에 `request[i]` 값이 빼지게 된다.
4. 이러한 과정을 모든 프로세스에 대해 반복한 뒤 모든 `finish[i]`가 True라면 안정상태가 된다.

#### 간단한 실습

![alt text](<스크린샷 2025-04-28 오후 3.17.37.png>)

안정상태가 되는 순서는 다음과 같다.
P1 -> P3 -> P4 -> P0 -> P2

1. P1 : 1, 2, 2에 해당하는 need[1]에 대한 자원을 할당하고 finish[1] = True로 만든다.
   `+` 2 0 0
   available : 5 3 2

2. P3 : 0, 1, 1에 해당하는 need[3]에 대한 자원을 할당하고 finish[3] = True로 만든다.
   `+` 2 1 1
   available : 7 4 3

3. P4 : 4, 3, 1에 해당하는 need[4]에 대한 자원을 할당하고 finish[4] = True로 만든다.
   `+` 0 0 2
   available : 7 4 5

4. P0 : 7, 4, 3에 해당하는 need[0]에 대한 자원을 할당하고 finish[0] = True로 만든다.
   `+` 0 1 0
   available : 7 5 5

5. P2 : 6, 0, 0에 해당하는 need[2]에 대한 자원을 할당하고 finish[2] = True로 만든다.
   `+` 3 0 2
   available : 10 5 7

#### 코드

```javascript
let n, m, i, j, k;
n = 5; // 프로세스의 갯수 0 ~ 4
m = 3; // 자원의 갯수
// 이미 할당한 양
let alloc = [
  [0, 1, 0], // P0
  [2, 0, 0], // P1
  [3, 0, 2], // P2
  [2, 1, 1], // P3
  [0, 0, 2], // P4
];
// 프로세스가 최대치로 요구하는 양
let max = [
  [7, 5, 3], // P0
  [3, 2, 2], // P1
  [9, 0, 2], // P2
  [2, 2, 2], // P3
  [4, 3, 3], // P4
];
// 운영체제의 가용할 수 있는 자원의 양
```

```javascript
let avail = [3, 3, 2],
  ans = [];
let need = Array.from({ length: n }, (v, i) =>
  Array.from(
    {
      length: m,
    },
    (v, j) => 0
  )
);
let finish = Array.from({ length: n }, (v, i) => 0);
for (i = 0; i < n; i++) {
  for (j = 0; j < m; j++) {
    need[i][j] = max[i][j] - alloc[i][j];
  }
}
//프로세스를 돌면서 확인합니다.
for (let k = 0; k < n; k++) {
  for (let i = 0; i < n; i++) {
    if (finish[i] == 0) {
      let flag = 0;
      for (j = 0; j < m; j++) {
        if (need[i][j] > avail[j]) {
          flag = 1;
          break;
        }
      }
      if (flag == 0) {
        ans.push(i);
        for (let y = 0; y < m; y++) avail[y] += alloc[i][y];
        finish[i] = 1;
      }
    }
  }
}
let safe_flag = 1;
for (let i = 0; i < n; i++) {
  if (finish[i] == 0) safe_flag = 0;
}
if (safe_flag) {
  console.log("안정상태 순서는 다음과 같습니다. ");
  for (let i = 0; i < n; i++) {
    console.log("Process " + ans[i]);
  }
} else {
  console.log("불안정상태입니다.");
}
```

---

### 은행원 알고리즘의 단점

- 프로세스가 시스템에 들어갈 때 필요한 최대 자원 수를 예측해야 하는데 이를 예측하기가 쉽지 않고 해당 알고리즘에 대한 자원 소모량이 증가하게 되며 프로그램의 수는 고정되어있지 않고 항상 변하기 때문에 쓰기가 어려운 단점이 있다.
