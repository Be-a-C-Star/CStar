## 🧩 1. 교착 상태 (Deadlock)

### ✅ 정의  
**교착 상태(Deadlock)**란, 여러 프로세스가 서로의 자원을 기다리며 무한히 대기하는 상태로, 아무 작업도 더 이상 진행될 수 없는 상태를 말합니다.

---

### 📌 교착 상태 발생 조건 (Coffman’s Conditions)

교착 상태는 아래 4가지 조건이 동시에 만족될 때 발생합니다:

1. **상호 배제(Mutual Exclusion)**: 자원을 한 번에 하나의 프로세스만 사용할 수 있음  
2. **점유 대기(Hold and Wait)**: 자원을 점유한 채 다른 자원을 기다림  
3. **비선점(No Preemption)**: 이미 할당된 자원을 강제로 회수할 수 없음  
4. **순환 대기(Circular Wait)**: 프로세스들이 원형으로 자원을 서로 기다리는 구조

---

### 🛠️ 교착 상태 해결 전략

| 전략 | 설명 |
|------|------|
| **예방 (Prevention)** | Coffman 조건 중 하나라도 **사전에 차단**하여 교착 상태 방지 |
| **회피 (Avoidance)** | 시스템 상태를 평가하여 **위험한 상태로 진입을 회피** |
| **탐지 및 복구 (Detection & Recovery)** | 교착 상태 발생 후 **탐지 알고리즘**으로 감지하고, 프로세스를 종료하거나 자원을 회수하여 복구 |
| **무시 (Ignore)** | 교착 상태 발생 확률이 낮다고 판단하여 별도 조치 없이 운영 (예: UNIX/Linux)

---

### 💳 은행원 알고리즘 (Banker’s Algorithm)

**회피(Avoidance)** 전략의 대표적인 알고리즘입니다.  
Dijkstra가 제안한 이 알고리즘은 **은행에서 대출을 처리하는 방식**을 모방합니다.

#### 🏦 핵심 아이디어
시스템은 자원을 할당하기 전에 해당 할당이 **안전 상태(Safe State)**로 이어지는지를 확인합니다.

#### 📘 주요 요소

- **Available**: 현재 시스템에서 사용 가능한 자원 수  
- **Max**: 각 프로세스가 요청할 수 있는 최대 자원 수  
- **Allocation**: 현재 각 프로세스에 할당된 자원  
- **Need = Max - Allocation**: 아직 필요한 자원 수

#### ✅ 안전 상태
모든 프로세스가 결국 자신의 최대 요구를 만족하고 종료할 수 있는 상태

#### 🔄 알고리즘 순서 요약

1. 요청이 왔을 때, 요청 ≤ Need 이고 요청 ≤ Available 인지 확인  
2. 일시적으로 자원을 할당한 후, 시스템이 **안전 상태**인지 검사  
3. 안전하면 진짜 할당, 위험하면 요청 거절

> 이 알고리즘은 계산량이 많아 실시간 시스템에는 잘 사용되지 않지만, **이론적으로 중요한 기반**이 됩니다.

---

## ⚙️ 2. CPU 스케줄링 알고리즘

### ✅ 정의  
CPU 스케줄링은 프로세스들에게 CPU를 **효율적이고 공정하게 분배**하는 방식입니다. 스케줄링 방식은 크게 **비선점형(Non-Preemptive)** 과 **선점형(Preemptive)** 으로 나눌 수 있습니다.

---

### 📂 비선점형 스케줄링 (Non-Preemptive Scheduling)

> 한 번 CPU를 할당받은 프로세스는 **스스로 종료하거나 I/O 요청 전까지** CPU를 계속 사용

#### 1. FCFS (First Come First Serve)
- 도착한 순서대로 실행
- 간단하지만 평균 대기 시간이 길어질 수 있음

#### 2. SJF (Shortest Job First)
- 실행 시간이 가장 짧은 작업 먼저 처리
- 최적의 평균 대기 시간 제공 (이론상)
- 실행 시간 예측이 어려우며, **기아 상태(starvation)** 발생 가능

#### 3. 비선점 우선순위 스케줄링
- 우선순위가 높은 프로세스를 먼저 실행
- 같은 우선순위면 FCFS 방식 적용
- 낮은 우선순위는 오래 기다릴 수 있음 → **Aging** 기법으로 해결 가능

---

### ⚡ 선점형 스케줄링 (Preemptive Scheduling)

> 실행 중인 프로세스가 있어도, 더 높은 우선순위 프로세스가 나타나면 **현재 작업을 중단하고 CPU를 넘김**

#### 1. Round Robin (RR)
- 고정된 시간 단위(Time Quantum)로 CPU를 순환 배정
- **공정성 보장** + 빠른 응답
- 타임 퀀텀이 너무 크면 FCFS처럼 되고, 너무 작으면 문맥 전환 오버헤드 증가

#### 2. 선점형 SJF (SRTF: Shortest Remaining Time First)
- 남은 실행 시간이 가장 짧은 프로세스를 실행
- 이론적으로 평균 대기 시간 가장 짧음
- 구현이 복잡하고 **실행 시간 예측** 필요

#### 3. 선점형 우선순위 스케줄링
- 더 높은 우선순위의 프로세스가 오면 현재 작업 중단
- 실시간 시스템에서 유용
- **기아 상태** 예방 위해 Aging 필요

---

### 📊 스케줄링 알고리즘 비교 표

| 알고리즘 | 선점 여부 | 공정성 | 평균 대기 시간 | 기아 현상 가능성 | 특징 |
|----------|------------|---------|----------------|-------------------|------|
| FCFS     | ✖ 비선점형 | 낮음    | 높음           | 없음              | 간단하지만 비효율적 |
| SJF      | ✖ 비선점형 | 낮음    | 낮음(이론상)   | 있음              | 실행 시간 예측 필요 |
| Priority | 둘 다 가능 | 낮음    | 중간           | 있음              | Aging 필요 |
| RR       | ✔ 선점형   | 높음    | 중간           | 없음              | 타임 퀀텀 조절 중요 |
| SRTF     | ✔ 선점형   | 낮음    | 가장 낮음(이론상) | 있음           | 예측 어려움 |
| MLQ / MFQ| ✔ 선점형   | 중간~높음| 유동적         | 설정에 따라 다름  | 다단계 큐 사용 |

---
