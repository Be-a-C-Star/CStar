### 서킷 브레이커

###### 서킷 브레이커 패턴이라고도 불리며 서비스 장애를 감지하고 연쇄적으로 생기는 에러를 방지하는 기법

- 서비스와 서비스 사이에 서킷브레이커 계층을 두고 미리 설정해놓은 timeout 임계값에 도달하면 서킷브레이커가 그 이후의 추가호출에 무조건 에러를 반환하게 한다.
- 서킷브레이커가 구현된 대표적인 라이브러리로는 넷플릭스의`Hystrix`와 `Resilience4j`가 대표적이다.

---

#### 서킷 브레이커가 필요한 사례

##### 1. 스레드의 차단

![alt text](<스크린샷 2025-03-04 오후 2.09.45.png>)

- 하나의 스레드가 차단되는 것은 괜찮다.
- 하지만 예를 들어 100개의 스레드가 있고 그중 98개의 요청이 에러가 있는 서비스에 요청을 한다면 정상적인 서비스에 요청한 나머지 2개의 스레드의 요청은 차단된다.

##### 2. 계단식 실패 발생

![alt text](<스크린샷 2025-03-04 오후 2.18.20.png>)

- 예를 들어서 장바구니, 카드, 결제로 이루어진 서비스가 있다고 했을때, 각 A, B, C는 서로 종속적이다.
- 서비스A에 장애가 난다면 어떻게 될까? B는 서비스 A의 응답을 하염없이 기다린다.
- 이어져있는 B, C 서비스의 응답도 지연되게 되며 계단식 실패가 발생한다.
  > 계단식 에러(Cascading failure)❓
  > 하나이상의 부품, 서비스 등의 고장이 연결되어있는 다른 부품, 서비스의 고장으로 이어지는 것을 말함

![alt text](<스크린샷 2025-03-04 오후 2.31.53.png>)

- 이런 상황에서 서비스 사이에 서킷 브레이커 계층을 두어 서비스 A에서 생긴 에러를 알려주고 서비스 B에게 더이상 A에게 요청하지 않도록 알리는 역할을 하여 연쇄적인 전파를 방지한다.
- 사용자 입장에서 응답을 오래 기다려야 하는 것은 좋은 UX가 아니다. 성공인지 실패인지는 중요하지 않고, 중요한 것은 사용자가 기다리지 않아야 한다는 점이기때문에 서킷브레이커로 막아줘야 한다.

---

#### 서킷브레이커 동작과정

![alt text](<스크린샷 2025-03-04 오후 2.36.45.png>)

#### 서킷브레이커의 상태

![alt text](<스크린샷 2025-03-04 오후 2.39.34.png>)

- 서킷브레이커는 closed, open, half_open 의 상태값을 가진다.
- 서비스를 운영하다 보면 서비스간 요청이 어느 정도는 실패한다. 따라서 어느 정도의 실패율을 미리 정해놓고 정해놓은 실패율을 넘어가면 에러가 있다고 판단한다.

##### closed(정상)

- 네트워크 요청의 실패율이 임계치보다 낮음

##### open(에러)

- 임계치이상의 상태를 말합니다. 요청을 서비스로 전송하지 않고 바로 오류를 반환한다.
- 이를 fail fast라고 한다.

##### half_open(확인중)

- open 상태에서 일정 timeout으로 설정된 시간이 지나면 장애가 해결되었는지 확인하기 위해 half_open 상태로 전환된다.
- 여기서 요청을 전송하여 응답을 확인한다. 장애가 풀리는지를 확인해서 성공하면 closed, 실패하면 다시 open으로 변경한다.

---

#### 서킷브레이커의 장점

- 연속적인 에러 발생을 막아주며 일부서비스가 종료되더라도 다른 서비스들은 이상없이 동작하게 만들 수 있으며 사용자 경험을 높여준다.
