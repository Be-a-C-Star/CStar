### TLS 핸드셰이크

#### TLS(Transport Layer Security)

###### 인터넷에서 데이터를 안전하게 주고받기 위한 암호화 통신 프로토콜. 흔히 웹에서 HTTPS라고 말할 때, 그 내부가 TLS를 이용해 암호화된 HTTP 통신을 말함

- TLS은 전송 계층에서 보안을 제공하는 프로토콜임
- 클라이언트와 서버가 통신 할 때 TLS를 통해 제3자가 메시지를 도청하거나 변조하지 못하도록 함

##### SSL(Secure Socket Layer)

- SSL 1.0부터 시작해서 SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.3까지 버전이 올라갔으며 마지막으로 TLS로 명칭이 변경됨

---

#### TLS 핸드셰이크 과정

![alt text](<스크린샷 2025-01-21 오후 9.34.16.png>)

- 사용할 TLS버전을 정하고, 사이퍼슈트, 서버의 공개키, SSL인증서를 기반으로 인증작업을 수행함. 이 후 대칭 암호화를 위해 세션키를 생성함

#### 1. Client Hello

- 클라이언트는 TLS버전, 사이퍼슈트와 클라이언트 랜덤값(무작위 문자열), 임시 DH
  매개변수를 서버에게 보냄

#### 2. Server Hello, EncryptedExtensions, Certificate, CertificateVerify

- 서버는 클라이언트로부터 받은 옵션을 확인
- 서버와 클라이언트 모두에서 지원하는 가장 높은 TLS 버전을 식별하며 결정, 사이퍼슈트 지원 여부를 확인함
- 공개키가 포함된 SSL 인증서, 서버 랜덤값, 임시 DH 매개변수를 보냄
- 클라이언트와 서버 각각 서로 교환한 DH 매개변수를 사용하여 임시 암호 키(세션키)를 생성함

#### Server Hello, EncryptedExtensions, Certificate, CertificateVerify 과정 상세 설명

**Server Hello**

- 서버는 클라이언트가 제공한 키 교환 매개변수를 기반으로 자신의 키 교환 매개변수를 생성하고 이를 클라이언트에게 전송함

**Encrypted Extensions**

- 필요한 추가 확장 정보를 암호화된 형태로 교환함

**Certificate**

- 서버는 자신의 인증서를 클라이언트에게 전송. 이 인증서에는 서버의 공개 키가 포함되어 있으며, 이를 통해 서버의 신원을 검증할 수 있음

**CertificateVerify**

- 서버는 자신의 개인 키를 사용하여 생성된 디지털 서명을 전송하여, 제공된 인증서의
  유효성과 서버의 소유권을 증명함

#### 3. Finished

- 서버와 클라이언트 모두 이전에 교환된 모든 메시지에 대한 무결성과 인증을 확인하는 메시지를 보내고 클라이언트와 서버와 세션키를 기반으로 대칭 암호화된 통신이 시작됨(보안세션이 시작되었다고도 말함)
- 키교환 알고리즘으로는 대표적으로 RSA와 DH가 있음
- TLS1.3버전에서는 RSA 같은 경우 취약점이 있기 때문에 공식적으로 지원하지 않음
- DH의 경우 타원곡선 DH를 사용함

---

#### DH(Diffie-Hellman) 매개변수

![alt text](<스크린샷 2025-01-21 오후 9.46.56.png>)

- Diffie-Hellman 알고리즘은 서로 공개값 공유, 비밀값과 혼합, 혼합값과 공유, 각자의 비밀값과 혼합해서 공통의 암호키를 만드는 알고리즘임
- DH는 그냥 디피헬만을 사용하는 `DHE`와 타원곡선암호화 방법과 DH를 섞은 `ECDHE`가 있고 보통 `ECDHE`를 사용함

> 타원 곡선 암호화 방법❓
> 곡선을 사용하여 개인 키 보유자만 알 수 있는 타원 곡선을 그리고 이걸 기반으로 교차점을 생성함. 이 교차점의 수를 기반으로 암호를 설정하는 방법

---

#### 사이퍼슈트

###### 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약을 말하며 암호제품군이라고도 함

- TLS1.3버전에는 다섯 개가 있습니다
  - TLS_AES_128_GCM_SHA256
  - TLS_AES_256_GCM_SHA384
  - TLS_CHACHA20_POLY1305_SHA256
  - TLS_AES_128_CCM_SHA256
  - TLS_AES_128_CCM_8_SHA256

##### Ex.

- **TLS_AES_128_GCM_SHA256**에는 세 가지 규약이 들어 있음을 뜻함
  - TLS: 프로토콜
  - AES_128_GCM: AEAD 사이퍼 모드
  - SHA256: 해싱 알고리즘

###### AEAD(Authenticated Encryption with Associated Data) 사이퍼 모드

- 데이터 암호화 알고리즘이며 AES_128_GCM 등이 있음
- 예를 들어 `AES_128_GCM`이라는 것은 128비트의 키를 사용하는 표준 블록 암호화 기술과 병렬 계산에 용이한 암호화 알고리즘 `GCM`이 결합된 알고리즘을 뜻함

###### 해싱 알고리즘

![alt text](<스크린샷 2025-01-21 오후 9.58.50.png>)

- 데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘
- SSL/TLS는 해싱 알고리즘으로 `SHA-256` 알고리즘과 SHA-384 알고리즘을 쓰는데, 그 중 `SHA-256`이 더 많이 사용됨
  - **SHA-256**: 해시 함수의 결괏값이 256비트인 알고리즘. 비트 코인을 비롯한 많은 블록체인 시스템에서도 사용

###### TLS에서 해싱 알고리즘의 용도

- 인증서가 올바른 인증서인지 확인할 때 전자서명을 이용하는데 이 때 해싱 알고리즘을 사용
  ![alt text](<스크린샷 2025-01-21 오후 10.01.25.png>)

1. 인증 생성작업 : 전자 서명을 만드는데 서명되는 메시지를 해싱함
2. 인증 확인작업 : 메시지를 복호화해서 해시를 서로 비교해 올바른 메시지인지 확인함

> 전자서명❓
> 송신자가 자신의 신원을 증명하는 절차 또는 정보

##### Ex.

###### 네이버에서 다운로드한 프로그램이 악성인지 아니면 정말로 네이버에서 공식적으로 다운로드한 프로그램인지 확인하려면 어떻게 해야할까?

- 프로그램 안에 제작자표시를 할 수 있음. 쉽게 조작을 못하도록 기술적인 장치를 기반으로 되어있고 이게 바로 전자서명임
- 전자서명을 통해 인증서에 적힌 주체가 '서비스제공자'인지 확인함
  - 인증서에 기록된 전자서명을 기반으로 CA의 공개키로 복호화해서 지문을 얻음
  - 인증서에 기록된 정보들을 해시 함수에 입력하여 해시를 얻어내서 두 해시의 일치 여부를 확인함
- 이를 통해 두 지문이 일치한다면 인증서 자체가 변조된 적이 없는 것을 뜻함
- 이를 통해 인증서의 **유효성을 검증**함
  - 즉, **유효성 검증**이란 인증서가 변조되지 않았고, 인증서가 '서비스제공자' 것임을 확인하는 절차임

---

#### 인증서

###### 주체, 공개키를 포함하는 단순한 데이터 파일

- **주체**: 인증서 발급한 CA, 도메인, 웹사이트 소유자, 인증서 소유자
- **공개키**: 공개키, 공개키암호화방법
  <br>
- 자신의 웹사이트 안에서 SSL 인증서를 만들 수도 있지만 보통은 인증기관인 CA에서 발급한 SSL인증서를 기반으로 인증작업을 수행함
- 주체는 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지 확인할 때 쓰이고 공개키는 처음 인증작업을 수행할 때 쓰임

---

#### CA(Certificate Authority)

###### 인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 하는데, 이 인증서를 발급하는 기업들을 CA라고 함

- 서비스의 도메인, 공개키와 같은 정보는 서비스가 CA로부터 인증서를 구입할 때 제출해야 함

![alt text](<스크린샷 2025-01-21 오후 10.13.40.png>)

- 인증서는 다양한 유형의 인증서가 있음
  - **단일 도메인**: 단 하나의 도메인에 적용되는 인증서
    - **Ex.** `www.naver.com`
  - **와일드카드**: 도메인의 하위 도메인도 포함하는 인증서
    - **Ex.** `www.cloudare.com`, `blog.cloudare.com`
  - **멀티 도메인**: 이름이 의미하는 것처럼 멀티 도메인 SSL 인증서는 관련되지 않은 다수의 도메인에 적용될 수 있는 인증서

---

#### RSA의 취약점

![alt text](<스크린샷 2025-01-21 오후 10.17.35.png>)

- RSA의 경우 클라이언트가 생성한 임시 암호값을 서버로 전송함
  - 이 때문에 RSA는 클라이언트에서 생성한 임시 암호값이 탈취당한 경우 해킹의 위험이 있음
- DH의 경우 클라이언트와 서버가 서로 교환한 DH 매개변수를 사용해 개인키를 만듦
  - DH의 경우 탈취당해도 공통의 암호키를 못 만들기 때문에 더 좋음

---

#### 0 - RTT

- 세션키가 생성된 이 후 다시 그 사이트에 방문한다면 미리 만들어 놓은 세션키(PSK, pre-shared key)를 기반으로 연결을 생성하기 때문에 이 때 인증에 드는 비용은 없음
- 즉, 인증에 관한 RTT가 발생되지 않기 때문에 0 - RTT 라는 특징을 가짐

##### 네트워크상 보안을 해야하는 이유

![alt text](<스크린샷 2025-01-21 오후 10.19.45.png>)

- 신용카드 등 민감한 금융정보를 다루는데 이점이 있고 HTTP/2를 구현할 수 있음
- HTTP/2는 보통 HTTPS 위에서만 돌아감
  - TLS계층을 선택적으로 쓸 수 있지만 보통은 HTTP/2를 쓸 때 TLS계층을 둠
