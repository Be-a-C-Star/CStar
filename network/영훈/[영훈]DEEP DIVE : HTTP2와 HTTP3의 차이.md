#### HTTP/2

- 2009년 구글은 HTTP/1.1의 한계를 극복하기 위해 SPDY 프로토콜을 개발함
- 이 후 2015년, SPDY를 기반으로 하는 HTTP/2 프로토콜을 만듦

##### 바이너리 포맷 계층

![alt text](<스크린샷 2025-01-21 오후 5.35.16.png>)

- 애플리케이션 계층과 전송 계층 사이에 바이너리 포맷 계층을 추가함
- HTTP 1.0은 일반 텍스트 메시지를 전송하고 줄바꿈으로 데이터를 나눔
- HTTP 2.0은 0과 1로 이루어진 바이너리 데이터로 변경되었고 더 작은 메시지가 프레임으로 캡슐화 되어서 전송됨

##### h2와 h2c

> TLS(Transport Layer Security)❓
> 인터넷에서 데이터를 안전하게 주고받기 위한 암호화 통신 프로토콜. 흔히 웹에서 HTTPS라고 말할 때, 그 내부가 TLS를 이용해 암호화된 HTTP 통신을 말함

- HTTP/2는 TLS를 선택적으로 사용 가능. 즉, TLS가 없는 HTTP/2도 있음
- h2c는 TLS를 사용하지 않고 TCP 연결 위에서 직접 HTTP/2를 사용하는 것을 의미함
  - 개발 환경에서의 디버깅이나 로컬 테스트를 위해 암호화된 연결을 설정할 필요가 없으므로 개발자들이 편리하게 테스트를 할 수 있다는 장점, 암호화와 관련된 오버헤드가 없다는 장점이 있음
- h2는 TLS가 장착된 HTTP2를 부르며 브라우저에서는 HTTPS가 없는 HTTP2는 지원하지 않기 때문에 브라우저에서는 h2c가 아니라 h2만 허용됨

##### 멀티플렉싱

![alt text](<스크린샷 2025-01-21 오후 5.49.22.png>)

- 단일 TCP연결의 여러 스트림에서 여러 HTTP 요청과 응답을 비동기적으로 보낼 수 있음. 이를 통해 HOL을 해결함
- HTTP/1.1에서는 병렬요청을 하려면 다중 TCP 연결을 통해서 하고 일반적으로는 TCP 연결 하나당 병렬 요청은 불가능함
- HTTP/2.0에서는 리소스를 작은 프레임으로 나누고 이를 스트림으로 프레임을 전달함
- 각각의 프레임은 스트림ID, 해당 청크의 크기를 나타내는 프레임이 추가되었기 때문에 작게 나눠서 다운로드가 되더라도 결과적으로 응답 데이터에서는 올바른 순서로 재조립이 가능함

##### 서버푸시

![alt text](<스크린샷 2025-01-21 오후 5.50.57.png>)

- 서버가 리소스를 클라이언트에 푸시를 할 수 있음
- 요청된 html파일과 함께 다른 개체를 별도로 보낼 수 있음
- 만약 요청한 html에 css가 포함되어있다면 별도 요청없이 css를 같이 보낼 수 있음

##### 헤더압축

> 허프만 인코딩❓
> 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트수를 사용해 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 전체 데이터 표현에 필요한 비트양을 줄이는 알고리즘

- HTTP/1.1에서는 무거운 헤더가 있었지만 이를 허프만 인코딩 압축 방법 등으로 압축시킴
- 똑같은 서버에서 2개의 이미지를 준다고 했을 때 중복되는 헤더는 제외 후 보내고 해당 공통 필드로 헤더를 재구성함
  - 예를 들어 `content-type-image-jpg`라는 헤더가 중복되면 하나를 없애고 클라이언트에 전달하고 클라이언트는 받을 때 공통된 헤더들을 재 조립함
- 중복되지 않은 헤더값은 허프만 인코딩 압축 방법으로 압축해 전송함

##### 우선순위

- 서버에서 원하는 순서대로 우선순위를 정해 리소스를 전달할 수 있음

---

#### HTTP/3

- HTTP/2는 여전히 TCP를 사용하기 때문에 초기 연결에 대한 RTT로 인한 지연 시간이라는 문제점이 있었고 이를 해결한 버전임
- QUIC(Quick UDP Internet Connections)이라는 계층 위에서 돌아가며, TCP 기반이 아닌 UDP 기반으로 돌아감
- HTTP/2에서 장점이었던 멀티플렉싱 등을 가지고 있으며 초기 연결 설정 시 지연 시간 감소라는 대표적 특성을 가지고 있음
  ![alt text](<스크린샷 2025-01-21 오후 6.08.57.png>)
- 또한 HTTP/2의 경우 3 - RTT가 필요했다면 QUIC은 1 - RTT만 필요하다는 장점이 있음
- HTTP/2의 경우 클라이언트와 서버간의 연결을 맺어 세션을 만드는데 필요한 핸드셰이크, 암호화 통신을 구축하기 위한 TLS 핸드셰이크가 각각 필요했음
- HTTP/3는 TLS로 암호화 통신을 구축할 때의 단 한번의 핸드셰이크를 활용해 클라이언트와 서버간의 연결, 암호화 통신 모두 다 구축함
  - 이를 통해 1 - RTT만에 모든 연결을 성립할 수 있음

![alt text](<스크린샷 2025-01-21 오후 6.11.32.png>)

- 그림처럼 HTTP/2는 각각 핸드셰이크가 필요하지만 HTTP/3는 단 한번의 핸드셰이크를 통해 1 - RTT만 필요한 것을 볼 수 있음
- 또한, 전송된 패킷이 손실 되었다면 수신측에서 에러를 검출하고 수정하는 방식임
- 열악한 네트워크 환경에서도 낮은 패킷손실률을 자랑하는 순방향 오류 수정 메커니즘(FEC, Forward Error Correction)이라는 특징을 가짐
