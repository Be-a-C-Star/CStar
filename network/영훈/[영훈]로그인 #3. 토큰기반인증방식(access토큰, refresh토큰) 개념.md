### 토큰 기반 인증

###### 상태를 토큰 자체만으로 처리하며 토큰을 처리하는 서버를 두고 다른 컨텐츠를 제공하는 서버는 모두 stateless 하게 만들자는 이론이 담긴 방식

##### 토큰을 관리하는 서버를 따로 두는 이유

###### Ex.

- 여러개의 서버를 운용한다라고 했을 때 장바구니를 담당하는 서버, 결제를 담당하는 서버가 있다면
- 장바구니를 관리하는 서버에 토큰 기반 인증까지 함께 구축할 경우 장바구니 서버에서 에러가 발생이 되면
- 인증에 관한 기능이 마비될 것이며 이는 다른 결제 서버 등의 기능까지 연쇄적으로 마비될 수 있기 때문임

##### 토큰 기반 인증 프로세스

![alt text](<스크린샷 2025-02-04 오후 3.46.34.png>)

1. 인증 로직 - JWT 토큰 생성(access 토큰, refresh 토큰)
2. 사용자가 이후에 access 토큰을 HTTP Header - Authorization 또는 HTTP Header Cookie에 담아 인증이 필요한 서버에 요청해 원하는 컨텐츠를 가져옴

---

#### JWT(JSON Web Token)

###### 헤더, 페이로드, 서명으로 이루어져 있으며 JSON 객체로 인코딩되어 메시지 인증, 암호화에 사용되는 토큰

![alt text](<스크린샷 2025-02-04 오후 3.51.47.png>)

- 점을 기준으로 Header, Payload, Signature로 구분되어 있음

##### Header

![alt text](<스크린샷 2025-02-04 오후 3.52.41.png>)

- 토큰 유형과 암호화에 사용된 알고리즘 등이 저장돼 있음
- base64URI로 인코딩 됨

##### Payload

![alt text](<스크린샷 2025-02-04 오후 3.54.56.png>)

- 데이터, 토큰 발급자, 토큰 유효기간 등이 저장돼 있음
- 저장하고 싶은 데이터 종류에 제한이 없음
- 공식적으로 사용되는 필드 이름을 사용 권장함(exp, iat, jti 등)
  - exp(expiration time): 만료 시간
  - iat(issued at): 발급 시간
  - jti: JWT ID
- base64URI로 인코딩 됨

##### Signature

![alt text](<스크린샷 2025-02-04 오후 3.56.03.png>)

- (인코딩된 header + payload) + 비밀키를 기반으로 헤더에 명시된 알고리즘을 통해 암호화한 서명
- 시크릿 키를 공유하고 있다면 토큰을 발행한 서버가 아니여도 여러 서비스들 사이에서 JWT를 공유할 수 있음
- 클라이언트에서 보낸 토큰의 헤더와 페이로드를 서버에서 가지고 있는 비밀키를 통해 직접 시그니처로 만들고,
  - 만든 시그니처와 토큰의 시그니처가 일치하면 해당 토큰은 시크릿 키를 알고있는 서버에서 발행했다는 것을 알 수 있음

---

#### 장점

- 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함하기 때문에 별도의 인증 저장소가 필요 없음
- REST에 부합하기 위해서는 서버가 상태 정보를 저장하지 않는, stateless 한 특성이 있어야 하는데 토큰 인증 방식은 토큰을 서버에 저장해두지 않고, 요청시 토큰 자체만을 해석하여 사용하기 때문에 RESTful API에 적합함
- 토큰을 발행하는 방법이 똑같고, 시크릿 키만 있으면 발행을 한 곳과 확인을 하는 곳이 달라도 되기때문에 유연함
  - **Ex.** 같은 유저 DB를 사용하는 여러 서비스들이 있고, 이 사이트들이 같은 방식과 키를 사용해서 토큰을 발행한다면 한 사이트에서 제공한 토큰을 가지고 있으면, 다른 서비스가 그걸 해석해서 유저를 파악할 수 있음
- 다른 유형의 토큰과 비교했을 때 경량화 돼있음
  - SAML(Security Assertion Markup Language Tokens)이란 토큰이 있지만 이에 비해 훨씬 경량화 되어있음
- 디코딩 했을 때 JSON이 나오기 때문에 JSON을 기반으로 쉽게 직렬화, 역직렬화가 가능함

#### 단점

- 토큰이 비대해질 경우 당연히 서버 과부화에 영향을 줄 수 있음
- 토큰을 탈취 당할 경우 디코딩 했을 때 데이터를 볼 수 있음
- 서버가 상태 정보를 저장하지 않기 때문에 특정 토큰을 무효화하는 게 더 복잡함
  - **Ex.** 금융 서비스에서 누군가 유저 토큰을 가로챘는데 이걸 바로 무효화할 수 없다면 돈을 뺏기는 문제가 생길 수도 있음
