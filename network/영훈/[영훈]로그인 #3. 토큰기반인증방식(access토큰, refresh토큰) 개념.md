### 토큰 기반 인증

###### 상태를 토큰 자체만으로 처리하며 토큰을 처리하는 서버를 두고 다른 컨텐츠를 제공하는 서버는 모두 stateless 하게 만들자는 이론이 담긴 방식

##### 토큰을 관리하는 서버를 따로 두는 이유

###### Ex.

- 여러개의 서버를 운용한다라고 했을 때 장바구니를 담당하는 서버, 결제를 담당하는 서버가 있다면
- 장바구니를 관리하는 서버에 토큰 기반 인증까지 함께 구축할 경우 장바구니 서버에서 에러가 발생이 되면
- 인증에 관한 기능이 마비될 것이며 이는 다른 결제 서버 등의 기능까지 연쇄적으로 마비될 수 있기 때문임

##### 토큰 기반 인증 프로세스

![alt text](<스크린샷 2025-02-04 오후 3.46.34.png>)

1. 인증 로직 - JWT 토큰 생성(access 토큰, refresh 토큰)
2. 사용자가 이후에 access 토큰을 HTTP Header - Authorization 또는 HTTP Header Cookie에 담아 인증이 필요한 서버에 요청해 원하는 컨텐츠를 가져옴

---

#### JWT(JSON Web Token)

###### 헤더, 페이로드, 서명으로 이루어져 있으며 JSON 객체로 인코딩되어 메시지 인증, 암호화에 사용되는 토큰

![alt text](<스크린샷 2025-02-04 오후 3.51.47.png>)

- 점을 기준으로 Header, Payload, Signature로 구분되어 있음

##### Header

![alt text](<스크린샷 2025-02-04 오후 3.52.41.png>)

- 토큰 유형과 암호화에 사용된 알고리즘 등이 저장돼 있음
- base64URI로 인코딩 됨

##### Payload

![alt text](<스크린샷 2025-02-04 오후 3.54.56.png>)

- 데이터, 토큰 발급자, 토큰 유효기간 등이 저장돼 있음
- 저장하고 싶은 데이터 종류에 제한이 없음
- 공식적으로 사용되는 필드 이름을 사용 권장함(exp, iat, jti 등)
  - exp(expiration time): 만료 시간
  - iat(issued at): 발급 시간
  - jti: JWT ID
- base64URI로 인코딩 됨

##### Signature

![alt text](<스크린샷 2025-02-04 오후 3.56.03.png>)

- (인코딩된 header + payload) + 비밀키를 기반으로 헤더에 명시된 알고리즘을 통해 암호화한 서명
- 시크릿 키를 공유하고 있다면 토큰을 발행한 서버가 아니여도 여러 서비스들 사이에서 JWT를 공유할 수 있음
- 클라이언트에서 보낸 토큰의 헤더와 페이로드를 서버에서 가지고 있는 비밀키를 통해 직접 시그니처로 만들고,
  - 만든 시그니처와 토큰의 시그니처가 일치하면 해당 토큰은 시크릿 키를 알고있는 서버에서 발행했다는 것을 알 수 있음
