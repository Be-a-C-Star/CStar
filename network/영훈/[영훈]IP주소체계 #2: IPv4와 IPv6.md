#### IPv4

###### 32비트로 표현되는 주소체계

![alt text](<스크린샷 2025-01-08 오후 12.28.19.png>)

- 2^32개의 주소(41억 9천만 주소)를 표현할 수 있음
- 8비트 단위로 점을 찍어 4개로 구분(8비트의 단위를 옥텟이라고 함)해서 표현
- 보통 8비트를 10진수로 표현해서 말함
- 이 주소체계만으로는 부족하기 때문에 NAT, 서브네팅 여러개의 부수적인 기술이 생겨남
- 8비트 = 옥텟 = 8바이트 모두 같은 말임

#### 옥텟

![alt text](<스크린샷 2025-01-08 오후 12.31.43.png>)

---

#### IPv6

###### 128비트로 표현되는 주소체계

![alt text](<스크린샷 2025-01-08 오후 12.34.08.png>)

- 2^128개의 주소를 표현할 수 있음
- 즉, 많은 주소 처리가능하며 NAT, 서브네팅이 필요하지 않음
- 16비트씩 8개로 구분하고 16비트는 16진수로 변환되어 콜론(:)으로 구분하여 표시하며 앞의 연속되는 0은 생략될 수 있음
  ![alt text](<스크린샷 2025-01-08 오후 12.36.22.png>)
- 앞의 64비트는 네트워크주소를 말하고 뒤 64비트는 인터페이스 주소(호스트 주소)로 이루어져 있음
- **IPSec**이 내장돼있음
  - **IPSec**: 데이터 패킷을 암호화 하는 보안 네트워크 프로토콜 제품군

---

#### IPv4와 IPv6의 차이점

##### 단순해진 헤더 포맷

![alt text](<스크린샷 2025-01-08 오후 12.39.52.png>)

- IPv6는 IPv4 헤더의 불필요한 필드를 제거하여 보다 빠른 처리 가능

  <br>

##### IPv4는 체크섬이 있지만 IPv6는 체크섬이 없음

- IPv4에는 CRC<sup>[1](#footnote_1)</sup>를 통한 손상된 패킷을 확인하고 폐기하는데 쓰는 체크섬필드(Header Checksum 필드)가 있음
- 그러나 IPv6는 해당 체크섬필드가 존재하지 않음
  - 이유는 상위 프로토콜(TCP, UDP)에 체크섬필드가 있기 때문에 헤더의 효율화를 위해 버전이 업그레이드되면서 사라졌기 때문임

![alt text](<스크린샷 2025-01-08 오후 12.45.48-1.png>)

- TCP Header, UDP Header 모두 체크섬 필드가 들어가 있음
- 체크섬 필드를 사용하지 않는 것으로 설정하고 싶다면 해당 필드의 값을 모두 0으로 만들면 됨
  - 이를 통해 체크섬 필드를 유동적으로 사용하거나 사용하지 않게 만들 수 있음
- 다만 IPv6 + UDP 로 사용할 경우 IPv6의 헤더 내에 체크섬 필드가 없기 때문에 무조건 UDP 헤더의 체크섬필드를 사용한다고 설정해야 함
- IPv4는 헤더가 가변 길이이고 IPv6는 고정 길이(40바이트)라서 **'인터넷 헤더길이'** 에 대한 정보, 식별, 플래그 등이 삭제됨

##### IPv6에서 TTL은 HOP limit로 대체됨

![alt text](<스크린샷 2025-01-08 오후 1.07.50.png>)

> TTL❓
> IPv4에서 TTL 필드는 패킷이 네트워크에서 무한순환하지 않도록 하는 변수
> 패킷이 네트워크에서 라우터를 거칠 때마다TTL 값이 1씩 감소. 값이 0이 되면 패킷이 폐기됨

##### IPv4와 IPv6 중 어떤게 더 좋은지?

- IPv6는 IPv4보다 많은 주소를 표현할 수 있음(주소 커버리지가 더 높음)
- IPv4보다 불필요한 헤더가 삭제되어서 빠름
- 기본적으로 IPSec이라는 네트워크 보안 제품군이 포함되었기 때문에 보안적인 측면에서도 좋음
- 보통은 IPv6를 사용하는 것이 속도가 더 빠름
  - IPv6에서 사용하는 더 큰 패킷 크기로 인해 일부 사용사례에서는 속도가 느린 경우도 있음

---

<a name="#footnote_1">1</a>: **CRC**❓

###### 순환중복검사로 네트워크상에서 데이터에 오류가 있는지 확인하기 위한 체크값을 결정하는 방식

- 데이터를 전송하기 전에 주어진 데이터의 값에 따라 CRC 값을 계산하여 데이터에 붙여 전송하고, 데이터 전송이 끝난 후 받은 데이터의 값으로 다시 CRC 값을 계산하게 됨
- 이어서 두 값을 비교하고, 이 두 값이 다르면 데이터 전송 과정에서 잡음 등에 의해 오류가 덧붙여 전송된 것임을 알 수 있음

##### Ex. CRC 라이브러리

![alt text](<스크린샷 2025-01-08 오후 1.04.13.png>)

- 'hello'라는 문자열을 CRC를 통해서 문자열로 변환함
