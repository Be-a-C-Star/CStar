브라우저에서 URL을 입력한 후 화면에 페이지가 렌더링되는 과정은 여러 단계로 이루어집니다. 주요 단계를 순서대로 설명하면 다음과 같습니다.

---

## 1. **URL 입력 및 요청 과정**
사용자가 주소창에 URL을 입력하고 Enter 키를 누르면 브라우저는 요청을 보내기 전에 여러 작업을 수행합니다.

### 1.1 **URL 해석**
- 사용자가 입력한 주소가 **검색어인지 URL인지** 판단합니다.
- `http://` 또는 `https://` 프로토콜이 누락된 경우 기본값(`https://`)을 붙입니다.

### 1.2 **브라우저 캐시 확인**
- 브라우저는 **캐시(Cache)** 에 저장된 리소스를 확인합니다.
- 요청된 페이지의 HTML, CSS, JavaScript, 이미지 등이 **캐시된 상태**라면 네트워크 요청 없이 캐시된 리소스를 사용합니다.
- **캐시가 없다면 네트워크 요청 진행**

---

## 2. **DNS 조회 (도메인 → IP 변환)**
URL에 포함된 도메인(예: `example.com`)을 IP 주소로 변환하기 위해 **DNS 조회**가 수행됩니다.

- **브라우저 캐시 확인** (이전 요청에서 캐싱된 DNS 응답 확인)
- **운영체제(OS) 캐시 확인** (`/etc/hosts` 파일 등)
- **로컬 DNS 서버 (ISP 제공) 조회**
- **최상위 DNS 서버 (Root DNS)** 까지 조회하여 IP 주소를 얻음

✅ 결과적으로 **해당 서버의 IP 주소**를 얻습니다.

---

## 3. **TCP / TLS 연결**
IP 주소를 알게 되면 브라우저는 웹 서버와 연결을 시도합니다.

### 3.1 **TCP 3-way Handshake**
- 브라우저와 서버 간에 **TCP 연결**을 수립합니다.
1. 클라이언트 → 서버 : **SYN** 패킷 전송 (연결 요청)
2. 서버 → 클라이언트 : **SYN-ACK** 응답 (수락)
3. 클라이언트 → 서버 : **ACK** 전송 (연결 완료)

### 3.2 **TLS 핸드셰이크 (HTTPS인 경우)**
- HTTPS의 경우 **SSL/TLS 인증서**를 사용해 데이터를 암호화합니다.
1. 클라이언트가 **지원 가능한 암호화 방식**을 서버에 보냄
2. 서버는 **자신의 SSL 인증서**를 클라이언트에게 제공
3. 클라이언트는 인증서를 검증한 후, 암호화 키 교환 진행
4. 안전한 **SSL/TLS 암호화 통신** 시작

---

## 4. **HTTP 요청 & 리다이렉트 처리**
### 4.1 **브라우저가 서버에 HTTP 요청 전송**
```http
GET / HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 ...
```

### 4.2 **서버의 응답 & 리다이렉트 처리**
- 서버는 요청을 처리한 후 응답을 보냅니다.
- 경우에 따라 **리다이렉트(301, 302)** 가 발생할 수 있습니다.
  - 예: `http://example.com` 요청 시, `https://example.com`로 **301 리다이렉트** 발생
  - 브라우저는 새로운 URL로 다시 요청을 보냅니다.

✅ 정상적인 응답(200 OK)을 받으면 **HTML 문서 다운로드 시작**

---

## 5. **HTML 파싱 & DOM 트리 생성**
HTML을 다운로드한 후 브라우저는 이를 **파싱(Parsing)** 하여 **DOM 트리(Document Object Model Tree)** 를 만듭니다.

1. `<html>`, `<head>`, `<body>` 태그를 읽으며 DOM 구조를 생성합니다.
2. **렌더링 차단 리소스 처리**
   - `<script>`, `<link>` 등의 리소스가 발견되면 네트워크 요청을 추가로 보냅니다.

---

## 6. **CSS 파싱 & 스타일 계산 (CSSOM 생성)**
HTML과 함께 CSS 파일도 다운로드한 후 파싱하여 **CSSOM(CSS Object Model)** 을 만듭니다.

1. `color: red;`, `display: flex;` 등의 스타일을 적용할 요소를 결정
2. CSS 규칙을 적용하여 최종 스타일 계산

✅ **DOM + CSSOM → 렌더 트리(Render Tree) 생성**

---

## 7. **JavaScript 실행**
- 브라우저는 `<script>` 태그를 만나면 해당 JavaScript 파일을 다운로드하고 실행합니다.
- **렌더링 차단 여부**
  - `async`: HTML 파싱과 병렬로 실행
  - `defer`: HTML 파싱이 끝난 후 실행
  - 일반 `<script>`: 실행될 때까지 HTML 파싱 중단

✅ JavaScript 실행이 끝나면 **DOM이 수정될 수 있음** → 다시 렌더링 필요

---

## 8. **레이아웃 계산 (Layout)**
브라우저는 **렌더 트리(Render Tree)** 를 기반으로 **각 요소의 위치와 크기를 계산**합니다.

- 뷰포트 크기, `position`, `width`, `height` 등에 따라 위치를 결정
- 예를 들어:
  ```css
  div {
    width: 50%;
  }
  ```
  → 부모 요소 크기를 확인 후, `width` 값을 픽셀 단위로 계산

---

## 9. **페인트(Paint)**
- 요소의 스타일(색상, 그림자, 배경 등)을 **픽셀로 변환**
- GPU를 사용해 그래픽 요소를 **레이어로 렌더링**

✅ 이 과정에서 `opacity`, `box-shadow` 같은 시각적 요소가 결정됨

---

## 10. **합성(Composite) & 디스플레이**
마지막으로 여러 레이어를 합쳐서 **최종 화면을 디스플레이** 합니다.

- GPU가 여러 레이어를 조합하여 **빠른 렌더링 처리**
- `transform`, `opacity` 변경은 **레이어 분리**되어 최적화됨
- 모든 요소가 픽셀 단위로 정리된 후, **최종 화면을 출력**

---

## 📌 전체 과정 요약
1. **URL 입력 & 브라우저 캐시 확인**
2. **DNS 조회 → 서버 IP 확인**
3. **TCP 연결 & TLS 핸드셰이크(HTTPS)**
4. **HTTP 요청 & 리다이렉트 처리**
5. **HTML 다운로드 & DOM 생성**
6. **CSS 다운로드 & CSSOM 생성**
7. **JavaScript 다운로드 & 실행**
8. **렌더 트리(Render Tree) 생성**
9. **레이아웃(Layout) 계산**
10. **페인트(Paint) → 픽셀로 변환**
11. **합성(Composite) & 화면 출력**
