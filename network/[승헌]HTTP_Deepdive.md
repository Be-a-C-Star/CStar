## HTTP/1.0와 HTTP/1.1의 차이

### HTTP/1.0

- 1996년에 표준화된 초기 버전
- 요청당 하나의 TCP 연결을 사용(짧은 수명)
→ RTT 증가(비효율적)

※ Round Trip Time: 왕복 지연시간

- 기본적으로 연결을 재사용하지 않음
- 각 요청마다 전체 헤더가 전송됨

### HTTP/1.1

- 1997년에 표준화됨
- HTTP/1.0의 단점을 보완한 프로토콜
- 주요 개선 사항:
    - **keep-alive default**: 기본적으로 TCP연결을 재사용하여 성능 개선
    - **호스트 헤더**: 가상 호스팅 지원을 위해 `Host` 헤더 필수화
        - HTTP/1.0은 서버가 하나의 호스트만 가진다고 가정
        - 여러 도메인을 하나의 서버에서 운영하기 어려움
        - `host` 헤더 필수화로 호스트를 식별할 수 있도록 함
    - **대역폭 최적화**: 청크 전송 인코딩(Chunked Transfer Encoding) 지원으로 데이터 스트리밍 가능
        - *e.g.* 다운로드 중 연결이 끊기면 다시 다운로드 받을 수 있도록 변경됨

## 요청을 줄이기 위한 기술

HTTP/1.1의 등장에도 요청 시 마다 RTT는 증가함

### 이미지 스프라이트

- 여러 이미지를 하나의 파일로 결합하여 요청 수 감소
- CSS 배경 위치 조정을 통해 필요한 부분만 표시

### 코드 압축

- HTML, CSS, JavaScript 파일에서 공백 및 불필요한 문자를 제거하여 크기 최소화
- Gzip, Brotli 등의 압축 알고리즘 활용

### Base64 인코딩

- 이미지를 Base64로 인코딩하여 HTML 또는 CSS에 직접 포함
- 추가 HTTP 요청을 줄이는 대신 파일 크기가 증가할 수 있음

## HTTP/1.1의 고질적 문제 HOL

- **Head-of-Line Blocking (HOL)**: 하나의 요청이 블로킹되면 이후 요청들이 대기해야 하는 문제
- 단일 TCP 연결을 통해 순차적으로 요청을 처리하는 방식의 한계

## HTTP/2와 HTTP/3의 차이

### HTTP/2

- 2015년에 표준화됨
- 구글의 SPDY 프로토콜을 기반으로 탄생
- 주요 개선 사항:
    - **바이너리 포맷 계층**: 텍스트 기반 대신 바이너리 프레이밍 사용으로 성능 향상
    - **멀티 플렉싱**: 단일 TCP 연결에서 여러 요청을 병렬(비동기)우와로 처리 가능
    - **서버 푸시**: 클라이언트가 요청하기 전에 서버가 리소스를 미리 전송
    - **헤더 압축**: HPACK 압축 방식으로 중복 헤더 제거 및 크기 감소
    - **우선순위**: 요청의 우선순위를 지정하여 중요한 리소스를 우선 로딩

### HTTP/3

- UDP 기반의 QUIC 프로토콜을 사용
- 1-RTT만 필요함
- 주요 개선 사항:
    - HOL 문제 해결: 개별 스트림 독립적 처리
    - 빠른 핸드셰이크로 지연 시간 감소
    - 패킷 손실 시 특정 스트림만 재전송

## HTTPS와 TLS

### 암호화란?

- 데이터를 보호하기 위해 암호화 적용
- 승인된 당사자만 정보를 이해할 수 있도록 함
- 전송 중 도청 및 변조 방지

### 스크램블

- 데이터를 특정 규칙에 따라 뒤섞어 원본 내용을 숨김
- 키 없이 해독하려면 아주 오랜 시간이 소요됨

### 대칭 암호화

- 동일한 키를 사용하여 데이터를 암호화 및 복호화
- AES(Advanced Encryption Standard) 등이 대표적

### 비대칭 암호화

- 공개 키와 개인 키를 사용하여 데이터 보호
- RSA, ECC 등이 대표적

### 암호화의 필요성

- 기밀성 유지
- 무결성 보장
- 인증 제공

## TLS 핸드셰이크

### TLS(Transport Layer Security protocol)

- 전송 계층에서 보안을 제공하는 프로토콜
- 클라이언트 - 서버 간 통신에 무결성 보장과 기밀 유지를 위함
1. Server Hello
    1. 서버는 클라이언트가 제공한 키 교환 매개변수를 기반으로 자신의 키 교환 매개변수를 생성
    2. 이를 클라이언트에게 전송
2. Encrypted Extensions
    1. 필요한 추가 확장 정보를 암호화된 형태로 교환
3. Certificate
    1. 서버는 자신의 인증서를 클라이언트에게 전송
    2. 이 인증서에는 서버의 공개 키가 포함됨
    3. 이를 통해 서버의 신원을 검증할 수 있음
4. Certificate Verify
    1. 서버는 자신의 개인 키를 사용하여 생성된 디지털 서명을 전송
    2. 제공된 인증서의 유효성과 서버의 소유권을 증명

### DH 매개변수

- 디피-헬만 키 교환 알고리즘을 이용하여 보안 키 공유

### 사이퍼슈트

- 암호화 알고리즘의 조합 (예: AES + SHA)

### 인증서

- 서버 신뢰성을 보장하기 위한 전자 문서
- 클라이언트가 서버의 진위를 확인 가능

### CA (인증 기관)

- 신뢰할 수 있는 제3자로부터 발급된 인증서를 통해 신뢰성 확보

### RSA의 취약점

- 충분히 긴 키 길이가 사용되지 않으면 취약
- 양자 컴퓨팅의 발전으로 보안 위협 증가

### 0-RTT

- 첫 번째 요청에서 핸드셰이크 과정을 생략하여 빠른 응답 제공
- 재전송 공격(Replay Attack) 방지를 위한 대책 필요
