
### 1. **세션 기반 인증(Session-based Authentication)**  
세션 기반 인증은 사용자가 로그인하면 서버가 세션을 생성하고, 이를 통해 사용자를 식별하는 방식이다.  

#### **동작 방식**  
1. 사용자가 로그인 요청을 보낸다 (ID, 비밀번호 등).  
2. 서버가 사용자의 자격 증명을 확인하고, 인증이 성공하면 세션을 생성한다.  
3. 생성된 세션의 ID(Session ID)를 쿠키에 저장하여 클라이언트에게 반환한다.  
4. 이후 클라이언트가 요청을 보낼 때마다 쿠키를 함께 전송하며, 서버는 쿠키의 세션 ID를 확인하여 사용자를 식별한다.  
5. 사용자가 로그아웃하거나 세션이 만료되면, 서버에서 해당 세션을 삭제한다.  

#### **장점**  
- 세션 ID는 서버에서 관리되므로 보안성이 높다.  
- 서버에서 세션을 직접 무효화할 수 있어 즉각적인 로그아웃 처리가 가능하다.  

#### **단점**  
- 서버에서 세션을 저장해야 하므로 확장성이 낮다. (사용자가 많아질수록 서버의 부담 증가)  
- 여러 개의 서버(로드 밸런싱)를 사용할 경우, 세션 공유를 위한 별도의 처리(Redis, Sticky Session 등)가 필요하다.  
- 쿠키를 이용하므로 XSS(크로스 사이트 스크립팅) 공격에 취약할 수 있다.  

---

### 2. **토큰 기반 인증(Token-based Authentication)**  
토큰 기반 인증은 서버가 세션을 저장하지 않고, 클라이언트가 직접 인증 정보를 포함한 토큰을 가지고 있는 방식이다. 대표적으로 JWT(JSON Web Token)가 많이 사용된다.  

#### **동작 방식**  
1. 사용자가 로그인 요청을 보낸다.  
2. 서버가 사용자의 자격 증명을 확인하고, 인증이 성공하면 JWT(토큰)를 생성하여 클라이언트에게 반환한다.  
3. 클라이언트는 이 토큰을 저장(브라우저의 localStorage, sessionStorage, 또는 쿠키)한다.  
4. 이후 클라이언트가 API 요청을 보낼 때, 요청 헤더(Authorization: Bearer {토큰})에 토큰을 포함하여 보낸다.  
5. 서버는 요청을 받을 때마다 토큰을 검증하여 사용자를 식별한다.  
6. 로그아웃 시 클라이언트에서 토큰을 삭제하면 된다.  

#### **장점**  
- 서버에서 인증 정보를 저장하지 않으므로 확장성이 높다. (무상태성, Stateless)  
- 로드 밸런싱 환경에서도 별도의 세션 공유가 필요하지 않다.  
- 모바일 앱, 웹 애플리케이션 등 다양한 플랫폼에서 사용하기 용이하다.  

#### **단점**  
- 토큰이 유효한 동안에는 언제든지 사용할 수 있으므로, 즉각적인 세션 만료(강제 로그아웃)가 어렵다.  
- 토큰을 안전하게 저장하지 않으면 탈취될 위험이 있다. (XSS, CSRF 방어 필요)  
- 토큰이 길어질 경우, 요청 시 데이터 전송량이 증가할 수 있다.  

---

### 3. **비교 요약**  

| 구분 | 세션 기반 인증 | 토큰 기반 인증 |
|------|--------------|--------------|
| 상태 유지 여부 | 서버에서 세션 관리 (Stateful) | 무상태 (Stateless) |
| 확장성 | 낮음 (서버 부하 증가) | 높음 (서버 부하 없음) |
| 저장 위치 | 서버 메모리 또는 DB | 클라이언트 (localStorage, 쿠키 등) |
| 인증 방식 | 세션 ID (쿠키 기반) | JWT 등 토큰 기반 |
| 보안 | 세션 탈취(XSS, CSRF) 위험 존재 | 토큰 탈취 위험 존재 (적절한 저장 방식 필요) |
| 강제 만료 | 서버에서 세션 삭제 가능 | 서버에서 토큰을 즉시 만료시키기 어려움 (단, 블랙리스트 방식 가능) |

---

### 4. **어떤 방식을 선택해야 할까?**  
- **세션 기반 인증**: 서버 중심의 웹 애플리케이션에서 사용하기 적합하며, 로그아웃 및 세션 만료를 엄격하게 관리해야 하는 경우 유리하다.  
- **토큰 기반 인증**: 확장성이 필요한 서비스(API 기반, 모바일 앱 등)에 적합하며, 다중 서버 환경에서 유리하다.  

실제 서비스에서는 두 가지 방식을 혼합하여 사용할 수도 있다. 예를 들어, **OAuth 2.0 방식**에서는 액세스 토큰(Access Token)을 이용한 토큰 기반 인증을 사용하면서, 리프레시 토큰(Refresh Token)을 활용하여 보안성을 강화하는 전략을 취하기도 한다.

