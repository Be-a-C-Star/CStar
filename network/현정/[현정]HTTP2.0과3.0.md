## HTTP/2

- 구글이 만든 SPDY 프로토콜을 기반으로 HTTP/2 프로토콜이 만들어짐
- 우선순위
    - 서버에서 원하는 순서대로 우선순위를 정해 리소스를 전달
- 바이너리 포맷 계층
    - 애플리케이션 계층과 전송 계층 사이에 바이너리 계층을 추가
    - 일반 텍스트 데이터를 0과 1로 이루어진 바이너리 데이터로 변경하여 프레임으로 캡슐화되어 전송
- 멀티 플렉싱
    - 단일 TCP 연결의 여러 스트림에서 요청과 응답을 비동기적으로 보냄
    - 리소스를 작은 프레임으로 나누고 캡슐화해서 StreamID와 legnth를 표시하여 헤더를 보냄
    - StreamID와 legnth를 기반으로 순서에 맞게 재조립함
- 서버 푸시
    - 서버가 리소스를 클라이언트에 푸시할 수 있음
    - 요청된 html 파일과 함께 다른 개체를 별도로 보냄
    - 만약 html에 css가 포함되어 있다면 요청 없이 css를 보내게 된다
- 헤더압축
    - 헤더를 허프만 인코딩 압축 방법 등으로 압축
    - 중복되는 헤더는 제외한 채 보내고 공통 필드로 헤더를 재구성하여 중복되지 않는 값만 압축하여 전송한다

> 허프만 코딩 : 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트수를 사용해 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 전체 데이터 표현에 필요한 비트량을 줄이는 알고리즘

### h2와 h2c

h2c는 TLS를 사용하지 않고 TCP 연결 위에 직접 HTTP/2를 사용하는 것을 의미한다. 로컬 테스트를 위해 암호화된 연결을 설정할 필요가 없어 개발 시 테스트가 편하며 암호화와 관련된 오버헤드가 없다.

h2는 tls가 장착된 http2이며 브라우저에서는 HTTPS가 없는 HTTP2는 지원하지 않기 때문에 h2만 허용된다.

## HTTP/3

- TCP를 사용하는 HTTP/2는 여전히 RTT로 인한 지연시간 문제가 있음
- QUIC(Quick UDP Internet Connections) 계층에서 동작
- UDP 기반
- 멀티플렉싱
- 초기 연결 설정 시 지연시간 감소
- 1 - RTT만 필요 : TLS 암호화 통신 시 한번의 핸드셰이크로 연결, 암호화 통신 모두 구축
- 전송된 패킷이 손실되면 수신측에서 에러를 검출하고 수정
- 순방향 오류 수정 매커니즘(FEC, Forward Error Correction) : 낮은 패킷 손실률을 가짐