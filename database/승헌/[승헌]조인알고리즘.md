## 조인 알고리즘

- MySQL에서는 사용자가 조인 알고리즘을 직접 지정할 수는 없음
- 대신 옵티마이저가 테이블 통계와 인덱스를 기반으로 가장 적절한 알고리즘을 자동 선택함
- `STRAIGHT_JOIN`, `optimizer_switch`, `JOIN_HINT` 등으로 동작을 어느 정도 조정 가능

```SQL
SET optimizer_switch="hash_join=off";
```

## 중첩루프조인 (Nested Loop Join)

- 두 테이블을 각각 루프를 돌면서 모든 조합을 비교
- 조인 조건에 맞는 결과를 반환

```SQL
SELECT *
FROM A, B
WHERE A.key = B.key;
```

### 특징

- 작은 테이블 간 조인에 적합
- 인덱스가 없거나 조건이 복잡한 경우 Fallback으로 자주 쓰임
- 속도 낮음 → 데이터양 많은경우 비효율

## 정렬병합조인 (Sort-Merge Join)

- 두 테이블 정렬 후, 병합하는 방식
- 각 테이블을 조인 키 기준 정렬
- 2개 포인터로 양쪽 테이블 순차 비교

### 특징

- 대용량 데이터에 적합
    - 정렬되어 있는 경우 매우 빠름
- 정렬 가능한 타입이 필요함(숫자, 문자열 등)
- 정렬 비용으로 작은 테이블엔 비효율적

## 해시조인 (Hash Join)

- 보통 작은 테이블에 대해 해시 테이블을 메모리에 로딩 (Build phase)
- 큰 테이블에서 이 해시를 기준으로 루프 (Probe phase)
    - 해시테이블에서 매칭되는 행이 있으면 결과 테이블에 추가

### 특징

- 동일 조인(equi-join)에 최적화
- **비등가 조건**에서는 사용 불가
- 작은 테이블을 메모리에 올려야만 함
- 큰 데이터셋에서 매우 효율적

### ✅ 동일 조인?:

- “두 테이블의 컬럼 값이 ‘같은 경우’만 연결”
- 즉, 조인 조건이 =(equal, 같음)인 경우
- 대부분의 조인(Inner Join, Outer Join)은 = 조건을 씀
- 해시 조인, 정렬 병합 조인은 이 조건에 **최적화**돼 있음

### ✅ 비등가 조건?:

- “같지 않은 조건”을 사용하는 조인
- <, >, !=, BETWEEN, LIKE 등을 쓰는 경우

```sql
SELECT *
FROM employees e
JOIN tax_brackets t ON e.salary BETWEEN t.min_salary AND t.max_salary;
```

- 해시 조인 사용 불가
(해시는 키값으로 직접 찾는 구조)
- 주로 중첩 루프 조인 또는 정렬 후 병합 조인으로 처리됨

## 시간복잡도/공간복잡도

| **조인 방식** | **시간 복잡도** | **공간 복잡도** | **특징** |
| --- | --- | --- | --- |
| 중첩 루프 조인 | O(N × M) | O(1) | 단순하지만 느림 |
| 정렬 병합 조인 | O(N log N + M log M) | O(N + M) | 정렬 필요, 대용량 적합 |
| 해시 조인 | O(N + M) (평균) | O(N) | 등가 조건에서 빠름 |

✅ 시간복잡도

- “데이터가 많아지면 실행 시간이 얼마나 느려지나?”

| O(1) | 입력 크기와 상관없이 항상 일정한 시간 (ex. 배열에서 인덱스로 접근) |
| --- | --- |
| O(log N) | 로그 단위로 빨라짐 (ex. 이진 탐색) |
| O(N) | 입력 크기만큼 선형 증가 (ex. 배열 한번 순회) |
| O(N log N) | 정렬 알고리즘처럼 약간 느림 |
| O(N^2) | 이중 반복문, 느림 |
| O(2^N) | 매우 느림 (재귀, 조합 등) |

✅ 공간복잡도

- “로직이 메모리를 얼마나 차지하나?”
    
    
    | O(1) | 고정된 크기만 사용하는 경우 |
    | --- | --- |
    | O(N) | 입력 개수만큼 메모리 사용하는 경우 |
    | O(N^2) | 2차원 배열 등 |