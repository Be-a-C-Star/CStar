## 데이터베이스?

데이터베이스(DB, DataBase)는 일정한 규칙을 통해 구조화되어 저장되는 데이터의 모음

트랜잭션, 동시 공유, 접근 권한 관리, 데이터 암호화, 백업/복구 등이 가능함

### 트랜잭션

여러 데이터 작업을 하나의 논리적인 작업 단위로 묶어 처리하는 기능

ACID(원자성, 일관성, 고립성, 지속성) 특성 보장

### 정규화(Normalization)

데이터 중복을 줄이고 일관성을 유지하기 위한 데이터베이스 구조화 기법

1NF, 2NF, 3NF등 단계가 있음

### DBMS(DataBase Management System)

데이터베이스를 관리하는 시스템

DBMS에 정의된 쿼리 언어를 통해 데이터 CRUD가 가능함

## 엔티티

DB에서 실제 개념을 모델링한 것

사람, 장소, 물건 처럼 여러개의 속성을 지님

DB내에서 고유하게 식별될 수 있는 속성을 가짐

약한/강한 엔티티로 나뉨

### 약한 엔티티

다른 강한 엔티티에 의존, 독립적으로 존재X

자체적인 키를 가지지 않고, 강한 엔티티의 키를 참조

### 강한 엔티티

자체적인 주요 키(Primary Key)를 가지고 있음

다른 엔티티에 의존하지 않고 독립적

## Key

### Primary Key

테이블에서 각 레코드를 식별하는 속성 또는 속성들

_e.g. users테이블의 id_

### Foreign Key

다른 테이블의 기본 키를 참조하는 속성

테이블 간 관계를 형성할 때 사용

_e.g. orders 테이블의 user_id는 users.id를 참조_

## 릴레이션

DB에서 정보를 구분해서 저장하는 기본 단위

엔티티의 집합, 각 엔티티 인스턴스는 릴레이션의 “레코드(행)”으로 표현됨

일반적으로 “테이블”이라고 불리고, 속성은 “열(column)”, 인스턴스는 “행(row)”이라고도 함

=> **‼️ JSON이랑 수직 방향으로 데이터가 나열됨**

NoSQL은 스키마가 유연하고 JSON 기반 문서, 키-값, 그래크, 컬럼 기반 등 다양한 모델이 존재함

## 속성과 도메인

### 속성

릴레이션에서 관리되는 고유한 이름을 갖는 정보(⇒ 필드)

### 도메인

릴레이션에 포함된 각 속성들이 가질수 있는 값의 집합

_e.g. 성별 속성의 도메인은 [“남”, “여”], 또는 [“M”, “F”]_

## 필드와 레코드

엔티티가 DB에 들어갈 때, 속성은 DB테이블의 필드(이름, 타입)로 변화됨

주로 영어로 표기

필드를 가진 데이터(=필드)들이 행단위로 쌓이게 되는데

이를 행단위 데이터(레코드, 튜플)이라고 부름

## 타입

타입은 DB마다 지원되는 내용이 다름

MongoDB는 단순 타입만 지원

MySQL은 세분화된 타입 지원

### 숫자

tinyint, smallint, mediumint, int, bigint

### 날짜

DATE: 날짜, (YYYY-MM-DD)

DATETIME: 날짜+시간, 8바이트, (YYYY-MM-DD HH:MM:SS)

TIMESTAMP: 날짜+시간, 4바이트, (1970-01-01 00:00:01부터 카운트한 값)

---

## CHAR / VARCHAR

### CHAR

- 테이블 생성 시 선언한 길이로 고정됨
- 1바이트(8비트, 0 ~ 255)

### VARCHAR

- 가변 길이 문자열
- VARCHAR(n): 최대 n개 문자 저장
- 실제 저장 크기는 문자 인코딩에 따라 달라짐 + 길이 정보(1 - 2바이트)
- 길이 정보 “0 ~ 255: 1바이트 / 256 ~ 65535: 2바이트 사용”

```sql
// 문자 당 3바이터 사용할 수 있음, 21844 * 3 = 65532 + 2byte 길이정보
CREATE TABLE t3 (
  c1 VARCHAR(21844) NOT NULL
);

// 문자셋을 ASCII(1byte)로 설정
CREATE TABLE t3 (
  c1 VARCHAR(65533) CHARACTER SET ascii NOT NULL
);
```

| **항목**    | CHAR(n)                                                  | VARCHAR(n)                               |
| ----------- | -------------------------------------------------------- | ---------------------------------------- |
| 저장 방식   | 고정 길이                                                | 가변 길이                                |
| 공간 사용   | 항상 n 문자 \* 바이트 수                                 | 실제 데이터 길이 × 바이트 수 + 길이 정보 |
| 길이 정보   | 없음                                                     | 1바이트(n ≤ 255), 2바이트(n > 255)       |
| 특징        | 짧고 자주 길이가 같은 문자열에 적합 (예: 성별, 우편번호) | 긴 문자열에 적합 (예: 이름, 설명)        |
| 문자셋 영향 | 문자당 바이트 수에 영향 있음                             | 문자셋에 따라 최대 길이 제한 영향 받음   |

### 문자 크기

- 영문, 숫자 등 ASCII 문자: 1바이트
- 한글, 일본어 등 유니코드: 2~3바이트(UTF-8 기준)

✅ 이모지는 하나의 문자로 취급(”😀”), 이모티콘은 텍스트의 조합으로 만들어짐(”^\_^”)

## TEXT, BLOB

### TEXT

- 최대 65,535개 길이 텍스트 데이터 저장

### VARCHAR vs TEXT

- TEXT는 내부적으로 VARCHAR와 유사하지만, 저장방식 및 인덱싱 제한이 다름

| **항목**  | VARCHAR                                                 | TEXT                                            |
| --------- | ------------------------------------------------------- | ----------------------------------------------- |
| 저장 위치 | **행 내부** (InnoDB page 내부)                          | **행 외부** (디스크의 별도 공간)                |
| 최대 크기 | 문자셋, 오버헤드 포함해서 최대 **65533자** (ascii 기준) | 최대 **65,535 바이트 (64KB)**                   |
| 인덱스    | 전체 가능                                               | 제한 있음 (ex: TEXT(100) 식으로 길이 지정 필요) |
| 사용 예   | 일반 텍스트, 짧은 설명                                  | 긴 설명, 사용자 후기 등                         |

### BLOB (Binary Large OBject)

- 이진(Binary) 데이터를 저장하는데 사용
- 이미지, 오디오, 비디오 등 저장
- 보통은 이미지호스팅(e.g. S3)을 이용해서 url을 저장하는 방식이 일반적임

### BLOB의 단점

- 성능문제, 큰 바이너리 파일을 저장하면 처리시간, 백업/복구 시간 증가
- 보안문제, 이미지에 대한 접근 제한 관리가 복잡해짐
- 이미지호스팅은 딸깍으로 처리할 수 있음

## ENUM, SET

### ENUM

- 열(값)에 할당할 수 있는 값의 리스트 정의
- 리스트 중 단일 선택만 가능
- 내부적으로 숫자로 매핑, 표시는 문자열로 됨
- 리스트 외의 값 넣으려고 하면 에러발생

### SET

- 하나의 열에 어러 값을 저장할 수 있음
- 비트단위 연산
- 한번에 여러개의 조합으로 선택이 가능함

```sql
CREATE TABLE socks (
id INT NOT NULL AUTO_INCREMENT,
colors SET('red', 'green', 'blue') NOT NULL,
PRIMARY KEY (id)
);
INSERT INTO socks (colors) VALUES ('red'), ('red,green'),
('green,blue'), ('red,green,blue');
SELECT * FROM socks;
```

| **항목**  | **ENUM**                         | **SET**                              |
| --------- | -------------------------------- | ------------------------------------ |
| 값의 개수 | 1개만 선택                       | 여러 개 선택 가능                    |
| 내부 저장 | **숫자 (1바이트~)**              | **비트 연산 (최대 64개)**            |
| 사용 예   | 상태값 (e.g. ‘배송중’, ‘완료’)   | 다중 옵션 (e.g. 색상, 알레르트 설정) |
| 확장성    | ENUM 값 추가 시 테이블 변경 필요 | SET도 마찬가지                       |

## 관계

### 관계 = 참조

- 객체 간 연관을 데이터베이스로 모델링 하기 위해 관계로 표현함
- 외래키를 통해 다른 테이블을 참조함

### 1 : 1 (One to One)

- 테이블의 레코드 간 1대1 대응되는 관계
- _e.g._ User - UserProfile,
  한 명의 유저는 하나의 프로필만 가짐

### 1 : N (One to Many)

- 레코드가 다른 테이블의 여러 레코드와 대응되는 관계
- _e.g._ Category - Product,
  하나의 카테고리에 여러 상품이 속함

### N : M (Many to Many)

- 두 테이블의 레코드들이 서로 여러개씩 대응
- _e.g._ User - Role,
  한 유저가 여러 역할을 가질 수 있고
  하나의 역할도 여러 유저에게 부여될 수 있음
- 보통 중간 테이블(Join Table)을 만들어서, 1:N + 1:N 구조로 구성
  _e.g._ UserRoles (user_id, role_id)

## 키

### 기본키 (PK, Primary Key)

- 테이블에서 각 레코드를 유일하게 식별할 수 있는 속성
- 중복, null 불가
- _e.g._ user_id

**자연키(Natural Key)**

- 실제 의미있는 데이터를 기본 키로 사용
- _e.g._ 주민등록번호, 이메일 등

**인조키(Surrogate Key)**

- 의미 없는 순번형 ID를 생성해서 사용
- _e.g._ UUID, 순차형넘버링

### 외래키 (Foreign Key)

- 다른 테이블의 기본키를 참조하는 컬럼
- 테이블관 관계 설정 시 사용
- 데이터 무결성 보장(부모테이블에 없는 ID 참조 방지)

### 후보키 (Candidate Key)

- 기본 키로 사용될 수 있는 모든 키 후보들
- 유일성, 최소성 만족
- 테이블에 여러 후보키가 존재할 수 있음

**최소성❓:** 후보키를 구성하는 속성 중 하나라도 제거하면, 유일성을 잃게 되는 성질

| **order_id** | **product_id** |
| ------------ | -------------- |
| 1001         | A              |
| 1001         | B              |
| 1002         | A              |

- order_id + product_id 조합이 최소성을 만족함

### 대체키 (Alternate Key)

- 후보키 중 기본키로 선택되지 않은 나머지 키를 말함
- _e.g._ 기본 키(user_id), 대체 키(email)

### 슈퍼키 (Super Key)

- 튜플을 유일하게 식별할 수 있는 속성들의 집합
- 후보키보다 더 넓은 개념, 최소성은 만족하지 않아도 됨

### 복합키 (Composite Key)

- 두 개 이상의 컬럼을 조합해서 만드는 키
- _e.g._ user_id + product_id → 찜 테이블의 기본키로 사용

## ERD

**ERD (Entity-Relationship Diagram)**는 데이터베이스 설계를 시각적으로 표현하는 **다이어그램 도구**

**어떤 데이터를 어떤 구조로 저장할지** 명확하게 하기 위해 쓰는 설계도

### **ERD 구성 요소**

1. **Entity (엔티티)**
   - **저장하고자 하는 데이터 집합**
   - 보통 **테이블**에 해당
   - 예: User, Product, Order
2. **Attribute (속성)**
   - 엔티티가 가지는 **속성값(컬럼)**
   - 예: User 엔티티 → id, name, email
3. **Relationship (관계)**
   - 엔티티 간의 **연관성**
   - 예: User - Order → 한 명의 유저가 여러 개의 주문을 할 수 있음 → **1:N 관계**

### **관계 표현 방식**

| **관계 유형** | **설명**                | **예시 표현**                         |
| ------------- | ----------------------- | ------------------------------------- |
| 1:1           | 한 엔티티당 하나만 연결 | User - Profile                        |
| 1:N           | 한 쪽은 여러 개 가능    | User - Order                          |
| N:M           | 양쪽 모두 여러 개 가능  | Product - Category (조인 테이블 필요) |

### **ERD의 목적**

- DB 설계 전에 **전체 구조를 미리 파악**할 수 있음
- 개발자, 기획자, 디자이너 간 **소통의 기준**
- 유지보수 시 **데이터 흐름 파악**에 도움

### 주로 쓰는 도구

- [draw.io](https://draw.io/)
- [dbdiagram.io](https://dbdiagram.io/)

## **조인**

두 개 이상의 테이블을 연결해서 데이터를 탐색

_e.g. MongoDB의 lookup 쿼리_

### **내부 조인 (INNER JOIN)**

- **두 테이블에 모두 존재하는 일치하는 값만 반환**
- 가장 일반적이고 기본적인 조인 방식
- 일치하지 않는 데이터는 결과에서 제외됨

```
SELECT *
FROM users
INNER JOIN orders ON users.id = orders.user_id;
```

### **외부 조인 (OUTER JOIN)**

**한쪽 테이블에만 있어도 결과에 포함되는 조인**

- **LEFT OUTER JOIN (LEFT JOIN)**
  왼쪽 테이블 기준. 오른쪽에 없으면 NULL로 채움
- **RIGHT OUTER JOIN (RIGHT JOIN)**
  오른쪽 테이블 기준. 왼쪽에 없으면 NULL로 채움
- **FULL OUTER JOIN**
  양쪽 모두 포함, 어느 한쪽에 없어도 NULL로 채움

### ✅ MongoDB의 populate

- LEFT OUTER JOIN과 가장 유사한 동작
- SQL JOIN: 한 번에 테이블끼리 붙여서 **하나의 테이블처럼** 반환
- populate(): 문서 내부에 ObjectId만 있다가, 그걸 실제 문서로 **지연 치환**하는 느낌

| **개념**     | **SQL** JOIN                                              | **MongoDB** populate()                          |
| ------------ | --------------------------------------------------------- | ----------------------------------------------- |
| 역할         | 외래키로 연결된 다른 테이블(릴레이션)에서 데이터 가져오기 | 참조된 ObjectId를 실제 문서 데이터로 채워넣기   |
| 동작 방식    | 즉시 테이블 조인 → 결과 합쳐서 반환                       | ObjectId로 참조 → 해당 document를 찾아서 붙여줌 |
| 언제 실행됨? | 쿼리 실행 시 바로                                         | .populate() 호출할 때 명시적으로                |

### **성능 비교**

> 인덱스가 잘 설정된 경우

| **JOIN 종류**   | **속도 (일반적으로)** | **설명**                |
| --------------- | --------------------- | ----------------------- |
| INNER JOIN      | ✅ 빠름               | 필터링 범위가 작기 때문 |
| LEFT/RIGHT JOIN | ⚠️ 느려질 수 있음     | NULL 채우는 비용        |
| FULL OUTER JOIN | ❗ 가장 느림          | 두 테이블 전체 스캔     |

---

## **교차 조인 & 자연 조인**

### **교차 조인 (CROSS JOIN)**

- **조건 없이 모든 조합을 반환**
- **카테시안 곱**이라고도 불림 → 결과 row 수 = A \* B

```
SELECT *
FROM products
CROSS JOIN categories;
```

> 실수로 쓰면 대량 데이터 생성되므로 주의

### **자연 조인 (NATURAL JOIN)**

- **두 테이블에 동일한 컬럼명**이 있을 때 자동으로 조인 조건 생성
- 명시적 ON 조건 필요 없음
- 명확하지 않아 잘 쓰이지 않음

```
SELECT *
FROM users
NATURAL JOIN orders;
```

> 현업에서는 **명시적 INNER JOIN** 사용

### **성능 비교**

- 교차조인은 조건 없으므로 무조건 느림 (데이터 폭발 위험)
- 자연조인은 내부적으로 INNER JOIN USING이므로 속도는 동일
- 그러나 **명시적 조인 조건이 없는 점** 때문에 유지보수 측면에서 비추천
