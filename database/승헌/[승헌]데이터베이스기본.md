## 데이터베이스?

데이터베이스(DB, DataBase)는 일정한 규칙을 통해 구조화되어 저장되는 데이터의 모음

트랜잭션, 동시 공유, 접근 권한 관리, 데이터 암호화, 백업/복구 등이 가능함

### 트랜잭션

여러 데이터 작업을 하나의 논리적인 작업 단위로 묶어 처리하는 기능

ACID(원자성, 일관성, 고립성, 지속성) 특성 보장

### 정규화(Normalization)

데이터 중복을 줄이고 일관성을 유지하기 위한 데이터베이스 구조화 기법

1NF, 2NF, 3NF등 단계가 있음

### DBMS(DataBase Management System)

데이터베이스를 관리하는 시스템

DBMS에 정의된 쿼리 언어를 통해 데이터 CRUD가 가능함

## 엔티티

DB에서 실제 개념을 모델링한 것

사람, 장소, 물건 처럼 여러개의 속성을 지님

DB내에서 고유하게 식별될 수 있는 속성을 가짐

약한/강한 엔티티로 나뉨

### 약한 엔티티

다른 강한 엔티티에 의존, 독립적으로 존재X

자체적인 키를 가지지 않고, 강한 엔티티의 키를 참조

### 강한 엔티티

자체적인 주요 키(Primary Key)를 가지고 있음

다른 엔티티에 의존하지 않고 독립적

## Key

### Primary Key

테이블에서 각 레코드를 식별하는 속성 또는 속성들

*e.g. users테이블의 id*

### Foreign Key

다른 테이블의 기본 키를 참조하는 속성

테이블 간 관계를 형성할 때 사용

*e.g. orders 테이블의 user_id는 users.id를 참조*

## 릴레이션

DB에서 정보를 구분해서 저장하는 기본 단위

엔티티의 집합, 각 엔티티 인스턴스는 릴레이션의 “레코드(행)”으로 표현됨

일반적으로 “테이블”이라고 불리고, 속성은 “열(column)”, 인스턴스는 “행(row)”이라고도 함

=> **‼️ JSON이랑 수직 방향으로 데이터가 나열됨**

NoSQL은 스키마가 유연하고 JSON 기반 문서, 키-값, 그래크, 컬럼 기반 등 다양한 모델이 존재함

## 속성과 도메인

### 속성

릴레이션에서 관리되는 고유한 이름을 갖는 정보(⇒ 필드)

### 도메인

릴레이션에 포함된 각 속성들이 가질수 있는 값의 집합

*e.g. 성별 속성의 도메인은 [“남”, “여”], 또는 [“M”, “F”]*

## 필드와 레코드

엔티티가 DB에 들어갈 때, 속성은 DB테이블의 필드(이름, 타입)로 변화됨

주로 영어로 표기

필드를 가진 데이터(=필드)들이 행단위로 쌓이게 되는데

이를 행단위 데이터(레코드, 튜플)이라고 부름

## 타입

타입은 DB마다 지원되는 내용이 다름

MongoDB는 단순 타입만 지원

MySQL은 세분화된 타입 지원

### 숫자

tinyint, smallint, mediumint, int, bigint

### 날짜

DATE: 날짜, (YYYY-MM-DD)

DATETIME: 날짜+시간, 8바이트, (YYYY-MM-DD HH:MM:SS)

TIMESTAMP: 날짜+시간, 4바이트, (1970-01-01 00:00:01부터 카운트한 값)

---

## CHAR / VARCHAR

### CHAR

- 테이블 생성 시 선언한 길이로 고정됨
- 1바이트(8비트, 0 ~ 255)

### VARCHAR

- 가변 길이 문자열
- VARCHAR(n): 최대 n개 문자 저장
- 실제 저장 크기는 문자 인코딩에 따라 달라짐 + 길이 정보(1 - 2바이트)
- 길이 정보 “0 ~ 255: 1바이트 / 256 ~ 65535: 2바이트 사용”

```sql
// 문자 당 3바이터 사용할 수 있음, 21844 * 3 = 65532 + 2byte 길이정보
CREATE TABLE t3 (
  c1 VARCHAR(21844) NOT NULL
);

// 문자셋을 ASCII(1byte)로 설정
CREATE TABLE t3 (
  c1 VARCHAR(65533) CHARACTER SET ascii NOT NULL
);
```

| **항목** | CHAR(n) | VARCHAR(n) |
| --- | --- | --- |
| 저장 방식 | 고정 길이 | 가변 길이 |
| 공간 사용 | 항상 n 문자 * 바이트 수 | 실제 데이터 길이 × 바이트 수 + 길이 정보 |
| 길이 정보 | 없음 | 1바이트(n ≤ 255), 2바이트(n > 255) |
| 특징 | 짧고 자주 길이가 같은 문자열에 적합 (예: 성별, 우편번호) | 긴 문자열에 적합 (예: 이름, 설명) |
| 문자셋 영향 | 문자당 바이트 수에 영향 있음 | 문자셋에 따라 최대 길이 제한 영향 받음 |

### 문자 크기

- 영문, 숫자 등 ASCII 문자: 1바이트
- 한글, 일본어 등 유니코드: 2~3바이트(UTF-8 기준)

✅ 이모지는 하나의 문자로 취급(”😀”), 이모티콘은 텍스트의 조합으로 만들어짐(”^_^”)

## TEXT, BLOB

### TEXT

- 최대 65,535개 길이 텍스트 데이터 저장

### VARCHAR vs TEXT

- TEXT는 내부적으로 VARCHAR와 유사하지만, 저장방식 및 인덱싱 제한이 다름

| **항목** | VARCHAR | TEXT |
| --- | --- | --- |
| 저장 위치 | **행 내부** (InnoDB page 내부) | **행 외부** (디스크의 별도 공간) |
| 최대 크기 | 문자셋, 오버헤드 포함해서 최대 **65533자** (ascii 기준) | 최대 **65,535 바이트 (64KB)** |
| 인덱스 | 전체 가능 | 제한 있음 (ex: TEXT(100) 식으로 길이 지정 필요) |
| 사용 예 | 일반 텍스트, 짧은 설명 | 긴 설명, 사용자 후기 등 |

### BLOB (Binary Large OBject)

- 이진(Binary) 데이터를 저장하는데 사용
- 이미지, 오디오, 비디오 등 저장
- 보통은 이미지호스팅(e.g. S3)을 이용해서 url을 저장하는 방식이 일반적임

### BLOB의 단점

- 성능문제, 큰 바이너리 파일을 저장하면 처리시간, 백업/복구 시간 증가
- 보안문제, 이미지에 대한 접근 제한 관리가 복잡해짐
- 이미지호스팅은 딸깍으로 처리할 수 있음

## ENUM, SET

### ENUM

- 열(값)에 할당할 수 있는 값의 리스트 정의
- 리스트 중 단일 선택만 가능
- 내부적으로 숫자로 매핑, 표시는 문자열로 됨
- 리스트 외의 값 넣으려고 하면 에러발생

### SET

- 하나의 열에 어러 값을 저장할 수 있음
- 비트단위 연산
- 한번에 여러개의 조합으로 선택이 가능함

```sql
CREATE TABLE socks (
id INT NOT NULL AUTO_INCREMENT,
colors SET('red', 'green', 'blue') NOT NULL,
PRIMARY KEY (id)
);
INSERT INTO socks (colors) VALUES ('red'), ('red,green'),
('green,blue'), ('red,green,blue');
SELECT * FROM socks;
```

| **항목** | **ENUM** | **SET** |
| --- | --- | --- |
| 값의 개수 | 1개만 선택 | 여러 개 선택 가능 |
| 내부 저장 | **숫자 (1바이트~)** | **비트 연산 (최대 64개)** |
| 사용 예 | 상태값 (e.g. ‘배송중’, ‘완료’) | 다중 옵션 (e.g. 색상, 알레르트 설정) |
| 확장성 | ENUM 값 추가 시 테이블 변경 필요 | SET도 마찬가지 |

## 관계

### 관계 = 참조

- 객체 간 연관을 데이터베이스로 모델링 하기 위해 관계로 표현함
- 외래키를 통해 다른 테이블을 참조함

### 1 : 1 (One to One)

- 테이블의 레코드 간 1대1 대응되는 관계
- *e.g.* User - UserProfile,
한 명의 유저는 하나의 프로필만 가짐

### 1 : N (One to Many)

- 레코드가 다른 테이블의 여러 레코드와 대응되는 관계
- *e.g.* Category - Product,
하나의 카테고리에 여러 상품이 속함

### N : M (Many to Many)

- 두 테이블의 레코드들이 서로 여러개씩 대응
- *e.g.* User - Role,
한 유저가 여러 역할을 가질 수 있고
하나의 역할도 여러 유저에게 부여될 수 있음
- 보통 중간 테이블(Join Table)을 만들어서, 1:N + 1:N 구조로 구성
*e.g.* UserRoles (user_id, role_id)

## 키

### 기본키 (PK, Primary Key)

- 테이블에서 각 레코드를 유일하게 식별할 수 있는 속성
- 중복, null 불가
- *e.g.* user_id

**자연키(Natural Key)**

- 실제 의미있는 데이터를 기본 키로 사용
- *e.g.* 주민등록번호, 이메일 등

**인조키(Surrogate Key)**

- 의미 없는 순번형 ID를 생성해서 사용
- *e.g.* UUID, 순차형넘버링

### 외래키 (Foreign Key)

- 다른 테이블의 기본키를 참조하는 컬럼
- 테이블관 관계 설정 시 사용
- 데이터 무결성 보장(부모테이블에 없는 ID 참조 방지)

### 후보키 (Candidate Key)

- 기본 키로 사용될 수 있는 모든 키 후보들
- 유일성, 최소성 만족
- 테이블에 여러 후보키가 존재할 수 있음

**최소성❓:** 후보키를 구성하는 속성 중 하나라도 제거하면, 유일성을 잃게 되는 성질

| **order_id** | **product_id** |
| --- | --- |
| 1001 | A |
| 1001 | B |
| 1002 | A |
- order_id + product_id 조합이 최소성을 만족함

### 대체키 (Alternate Key)

- 후보키 중 기본키로 선택되지 않은 나머지 키를 말함
- *e.g.* 기본 키(user_id), 대체 키(email)

### 슈퍼키 (Super Key)

- 튜플을 유일하게 식별할 수 있는 속성들의 집합
- 후보키보다 더 넓은 개념, 최소성은 만족하지 않아도 됨

### 복합키 (Composite Key)

- 두 개 이상의 컬럼을 조합해서 만드는 키
- *e.g.* user_id + product_id → 찜 테이블의 기본키로 사용