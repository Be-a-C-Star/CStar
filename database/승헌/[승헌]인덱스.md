
## 인덱스의 구조와 효율성

### B-Tree (Balanced Tree)

> **균형잡힌 다진 탐색 트리**
> 

디스크 기반 저장장치에서 읽기/쓰기 횟수를 최소화 하기 위해 고안된 자료구조

DB인덱스로 가장 널리 사용됨

- 정렬된 자료구조, 이진 트리보다 넓고 얕게 저장
- 노드: 키(key)와 자식 포인터로 구성
- 균형트리
    - 삽입/삭제 이후에도 트리 높이가 일정하게 유지됨

### 특징

| **N진 트리** | 각 노드는 **최대 M개의 자식 노드**를 가질 수 있음 (M은 차수) |
| --- | --- |
| **균형 유지** | 모든 리프 노드는 **동일한 레벨에 존재**함 (균형 트리) |
| **정렬 유지** | 노드의 키는 항상 **오름차순 정렬** |
| **동적 확장** | 데이터가 삽입/삭제되어도 **높이를 최소로 유지**하며 자동으로 재구성 |

**값의 범위를 기준으로 하위 노드를 나누고**,

**하위 노드가 초과되면 자동으로 분할(split)되면서 트리를 재조정**

범위를 기준으로 이진 탐색(또는 이분 결정)으로 값을 찾아감

깊이가 얕아서 디스크 접근(블록 접근)이 적음, 고로 속도가 빠르다

### 효율성

- 탐색, 삽입, 삭제 - O(log n) 복잡도
- 범위 쿼리(e.g. BETWEEN, LIKE “abc%” 등)에 매우 효율적
- 디스크 I/O를 최소화 하는 구조(DB에서 매우 중요함)

---

## 인덱스 성능 최적화

### 인덱스와 비용

- 인덱스는 `SELECT` 성능 향상
- `INSERT` / `UPDATE`/`DELETE`에는 오버헤드 발생
- 쿼리플랜을 통해 인덱스 사용 여부를 확인 가능함

### 과한 인덱싱

- 쓰기성능 저하
- 디스크 공간 낭비
- 쿼리 옵티마이저가 잘못된 인덱스 선택 위험 증가

### 테스팅

- 쿼리에 `EXPLAIN` 사용
- 어떤 인덱스를 타는지 확인 가능
- type, row, key, ref, Extra 정보 분석
    
    ```sql
    EXPLAIN SELECT * FROM users WHERE age = 30;
    ```
    

### 복합 인덱스

- **두 개 이상의 컬럼을 포함하는 인덱스**
    
    ```sql
    CREATE INDEX idx ON users (age, gender);
    ```
    
- 인덱스 컬럼 순서가 중요함
    - 위 인덱스는 WHERE age = ? AND gender = ?, WHERE age = ?는 가능
    - 하지만 WHERE gender = ? 단독으로는 인덱스가 **제대로 안 먹힘**

---

## Clustered Index

### **Clustered Index (클러스터형 인덱스)**

- **실제 데이터가 인덱스 순서대로 저장**
- 테이블당 **1개만 존재 가능**
- 기본 키(PK)가 자동으로 clustered index가 되는 경우가 많음 (MySQL InnoDB 기준)

### **장점**

- 범위 검색, 정렬, 순차적 검색에 매우 유리
- 데이터 접근 시 **추가적인 레벨 없이 바로 접근 가능**

### **단점**

- 데이터 재배치(리빌드)가 발생하면 I/O 비용 증가
- 잦은 업데이트/삽입에는 부적합할 수 있음

---

### **Non-Clustered Index (비클러스터형 인덱스)**

- **인덱스와 실제 데이터가 분리되어 저장**
- 인덱스에는 **데이터의 위치(ROW POINTER)** 만 존재
- **테이블당 여러 개 생성 가능**

### **장점**

- 특정 컬럼만 대상으로 여러 인덱스 생성 가능
- 데이터 정렬과 무관하게 인덱스 생성 가능

### **단점**

- 인덱스 → 데이터 페이지 2단계 접근 (추가 I/O)
- SELECT는 빠르지만, INSERT/UPDATE 시 유지 비용 증가