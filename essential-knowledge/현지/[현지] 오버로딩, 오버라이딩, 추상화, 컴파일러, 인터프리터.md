# 오버로딩 / 오버라이딩 / 추상화 / 컴파일러 / 인터프리터

## 오버로딩과 오버라이딩

### 오버로딩

같은 클래스 내에서 이름이 같아도 매개변수 개수, 타입, 순서를 다르게 해서 같은 이름으로도 여러 개의 함수를 정의할 수 있는 것이다.

#### 오버로딩의 조건

- 메소드의 이름이 같고, 매개변수의 개수나 타입이 달라야 한다.
- 리턴 값만 다른 것은 오버로딩을 할 수 없다.
- 접근 제어자도 자유롭게 지정해 줄 수 있으나 접근 제어자만 다르게 한다고 오버로딩이 가능하지는 않다.

```js
class Calculator {
  // 오버로딩 선언부
  add(a: number, b: number): number;
  add(a: string, b: string): string;

  // 실제 구현부
  add(a: any, b: any): any {
    return a + b;
  }
}

const calculator = new Calculator();

console.log(calculator.add(10, 20)); // 30
console.log(calculator.add("Hello, ", "TypeScript!")); // "Hello, TypeScript!"
```

#### 오버로딩을 사용하는 이유

> 같은 기능을 하는 메소드를 하나의 이름으로 사용할 수 있다.

ex) println의 인자 값으로 int, double, boolean, String 등의 아주 다양한 타입의 매개변수들을 집어넣어도 우리는 그 함수들이 어떻게 실행되지는 모르지만 콘솔창에 아주 잘 출력해주는 것을 볼 수 있다.

> 메소드의 이름을 절약할 수 있다.

ex) println을 매개변수의 종류에 따라서 다르게 지정한다고 생각해보면 printlnInt, printlnDouble, printlnBoolean 등 수많은 메소드들의 이름을 정해줘야 할 것이다. 하지만 오버로딩을 통해 이와 같은 메소드의 네이밍에 고민을 하지 않아도 된다.

### 오버라이딩

부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의 하는 것을 오버라이딩이라고 한다. 상속받은 메소드를 자식 클래스에서 상황에 맞게 변경해야하는 경우 사용된다.

#### 오버라이딩의 조건

- 부모 클래스의 메소드를 재정의하는 것이기 때문에 자식 클래스에서는 오버라이딩하고자 하는 메소드의 이름, 매개변수, 리턴 값이 모두 같아야 한다.
- static, final로 선언한 메소드는 오버라이딩이 불가능하다.
- 부모 클래스의 메소드를 오버라이딩하는 것은 내용만을 새로 정의하는 것이므로 선언부는 부모의 것과 완벽히 동일해야 한다.

```js
// 부모 클래스
class Animal {
  speak(): void {
    console.log('Animal is making a sound');
  }
}

// 자식 클래스
class Dog extends Animal {
  // 부모 클래스의 speak 메서드를 오버라이딩
  speak(): void {
    console.log('Dog is barking');
  }
}

const animal = new Animal();
animal.speak(); // "Animal is making a sound"

const dog = new Dog();
dog.speak(); // "Dog is barking"
```

#### 오버로딩과 오버라이딩의 차이

오버로딩: 기존에 없는 새로운 메소드를 추가하는 것
오버라이딩: 상속받은 메소드를 재정의 하는 것

| **구분**        | **Overriding**                                                                                               | **Overloading**                    |
| --------------- | ------------------------------------------------------------------------------------------------------------ | ---------------------------------- |
| **접근 제어자** | 부모 클래스의 메소드의 접근 제어자보다 더 넓은 범위의 접근 제어자를 자식 클래스의 메소드에서 설정할 수 있다. | 모든 접근 제어자를 사용할 수 있다. |
| **리턴형**      | 동일해야 한다.                                                                                               | 달라도 된다.                       |
| **메소드명**    | 동일해야 한다.                                                                                               | 동일해야 한다.                     |
| **매개변수**    | 동일해야 한다.                                                                                               | 달라야만 한다.                     |
| **적용 범위**   | 상속 관계에서 적용된다.                                                                                      | 같은 클래스 내에서 적용된다.       |

## 추상화

객체 지향 프로그래밍에서 의미하는 추상화는 객체의 공통적인 속성과 기능을 추출하여 정의하는것을 의미한다. 추상화는 크게 데이터 / 프로세스로 나뉜다.

### 데이터 추상화

데이터들의 공통점을 모으고 차이점은 버린다. 객체들의 공통적인 특징을 묶어 카테고리화 시킨다.

### 프로세스 추상화

프로세스 추상화는 사용자가 내부 로직에 신경 쓰지 않고 객체의 기능을 사용할 수 있도록 설계하는 방법이다. 이로 인해 사용자(프로그래머)는 동작을 실행하는 방법을 알 필요 없이 그 동작을 사용할 수 있다.

## 컴파일러와 인터프리터

프로그래밍 언어로 작성된 코드를 컴퓨터가 이해할 수 있는 기계어로 변환하는 과정에 관여하는 프로그램이다.

### 컴파일러

- 컴파일러는 특정 프로그래밍 언어를 다른 프로그래밍 언어로 옮기는 번역 프로그램이다.
- 보통 high-level 프로그래밍 언어를 low-level language인 기계어, 어셈블리어 등으로 바꾸는데에 사용된다.
- 컴파일러는 파일 전체를 한꺼번에 번역하여 번역한 결과를 컴퓨터가 실행가능한 목적 프로그램으로 저장한다.

#### 컴파일러의 장점

- 컴파일이 완료된 실행 파일은 컴퓨터에서 빠르게 실행해서 전체적인 실행 시간에서 효율적이다.
- 0과 1로 된 기계어로 번역되기 때문에 프로그램의 코드가 유출되지 않는다.

#### 컴파일러의 단점

- 코드를 수정하면 컴파일을 다시 해야한다.
- 실행 파일 전체를 컴파일 해야하므로 용량이 크다. 따라서 수정사항이 빈번할 경우 문제가 발생한다.
- 모든 프로그램을 한꺼번에 번역하기 때문에 컴파일링 시간이 비교적 느리다.
- 특정 시스템에서 만들어진 실행 파일이 다른 시스템에서는 실행되지 않는 경우가 많다.
- 목적프로그램 생성을 위한 메모리를 사용한다.

### 인터프리터

고급 언어로 작성된 프로그램을 한 줄 단위로 받아들여 번역하고, 번역과 동시에 프로그램을 한 줄 단위로 즉시 실행시키는 번역기이다. 인터프리터는 컴파일러와 대조적으로 코드를 한 줄씩 해석하여 실행하는 프로그램이다.
컴파일러와 달리 목적파일을 생성하지 않기 때문에 메모리를 사용하지 않는다.

#### 인터프리터 장점

- 메모리를 사용하지 않는다.
- 시스템간 이식성이 뛰어나다.
- 전체코드를 다시 컴파일할 필요가 없어서 코드 수정에 용이하다.

#### 인터프리터 단점

- 실행속도가 컴파일러에 비해 느리다.
- 바이트 코드로 해석되기 때문에 프로그램의 코드가 유출될 수 있다.
